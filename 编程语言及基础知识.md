# 编程语言及基础知识

## c++

### 访问限定符
private, public, protected 访问标号的访问范围。

- private：只能由1.该类中的函数、2.其友元函数访问。
不能被任何其他访问，该类的对象也不能访问。

- protected：可以被1.该类中的函数、2.子类的函数、以及3.其友元函数访问。
但不能被该类的对象访问。

- public：可以被1.该类中的函数、2.子类的函数、3.其友元函数访问，也可以由4.该类的对象访问。

注：友元函数包括3种：设为友元的普通的非成员函数；设为友元的其他类的成员函数；设为友元类中的所有成员函数。

第二：类的继承后方法属性变化。
- private 属性不能够被继承。
- 使用private继承，父类的protected和public属性在子类中变为private；
- 使用protected继承，父类的protected和public属性在子类中变为protected；
- 使用public继承，父类中的protected和public属性不发生改变;


### 重载

只要它们的参数列表不同就可以，这就是函数的重载（Function Overloading）。借助重载，一个函数名可以有多种用途。

参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。

### 多继承与多重继承

1. 多继承 多继承是指一个子类继承多个父类。多继承对父类的个数没有限制，继承方式可以是公共继承、保护继承和私有继承，不写继承方式，默认是private继承
2. 多重继承

    （1）多重继承与多继承不同，当B类从A类派生，C类从B类派生，此时称为多重继承
    
    （1）当实例化子类时，会首先依次调用所有基类的构造函数，最后调用该子类的构造函数；销毁该子类时，则相反，先调用该子类的析构函数，再依次调用所有基类的析构函数。
    
    （2）无论继承的层级有多少层，只要它们保持着直接或间接的继承关系，那么子类都可以与其直接父类或间接父类构成 is a的关系，并且能够通过父类的指针对直接子类或间接子类进行相应的操作，子类对象可以给直接父类或间接父类的对象或引用赋值或初始化。


### 虚继承

解决菱形继承问题

为了解决从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。这时从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，同一个函数名也只有一个映射。这样不仅就解决了二义性问题，也节省了内存，避免了数据不一致的问题。
```
class A; 
class B:vitual public A; 
class C:vitual public A; 
class D:public B,public C; 
```


### 多态概念

多态基础
1. 要有继承
2. 要有虚函数重写
3. 父类指针(引用)指向子类对象

### 早绑定vs晚绑定

早绑定指在对象申明的时候就和他的类型建立了关联

晚绑定是指我们的代码在运行时再检查对象是否提供了我们所需要的方法和属性

- 编译时多态性（静态多态）：通过重载函数实现
- 运行时多态性（动态多态）：通过虚函数实现。

### 隐藏与覆盖


### 虚函数和虚析构函数

C++的虚函数主要作用是“运行时多态”，父类中提供虚函数的实现，为子类提供默认的函数实现。子类可以重写父类的虚函数实现子类的特殊化。

虚析构函数主要用来解决父类指针指向子类对象时，分配内存而不能通过父类指针释放，发生内存泄露的问题。

### 纯虚函数与接口类

C ++ 中的纯虚函数更像是只提供申明，没有实现，是对子类的约束，是“接口继承”。
C++中的纯虚函数也是一种“运行时多态”。
类包含纯虚函数，就是“抽象类”


接口类就是只提供接口不提供实现的类，就是接口类，接口类和抽象类对C++而言，没有什么区别。

接口类有如下特点：

- 子类来实现接口类中没有实现的所有接口。
- 接口方法前面有virtual关键词修饰，并且等于0。
- 只能被继承，不能独自生成对象。

### 虚函数表

在发生多态的地方，也就上面的，编译器根本不会去区分，传进来的是子类对象还是父类对象。而是关心print()是否为虚函数，如果是虚函数，就根据不同对象的vptr指针找属于自己的函数。而且父类对象和子类对象都会有vptr指针，传入对象不同，编译器会根据vptr指针，到属于自己虚函数表中找自己的函数。即：vptr--->虚函数表------>函数的入口地址，从而实现了迟绑定(在运行的时候，才会去判断)。

- 当类中声明虚函数时，编译器会在类中生成一个虚函数表
- 虚函数表是一个存储类成员函数指针的数据结构
- 虚函数表是由编译器自动生成与维护的，virtual成员函数会被编译器放入虚函数表中

## python

### 静态动态语言 强类型弱类型 编译型解释型

### 装饰器

装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。

	def debug(func):
	    def wrapper(*args, **kwargs):  # 指定宇宙无敌参数
	        print "[DEBUG]: enter {}()".format(func.__name__)
	        print 'Prepare and say...',
	        return func(*args, **kwargs)
	    return wrapper  # 返回

	@debug
	def say(something):
	    print "hello {}!".format(something)

### 垃圾回收

## 计算机基础

### 进程和线程区别

进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元；同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进程至少包括一个线程。线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源。


### TCP UDP 区别
1. TCP协议在传送数据段的时候要给段标号；UDP 协议不需要。
2. TCP协议可靠；UDP协议不可靠。
3. TCP协议是面向连接；UDP协议采用无连接。
4. TCP协议负载较高,采用虚电路；UDP协议低负载。
5. TCP协议的发送方要确认接受方是否收到数据段(3次握手协议)。
6. TCP协议采用窗口技术和流控制。


### 三次握手 四次握手

### Ddos攻击

### 子网掩码

### OSI参考模型
ip 网络层
tcp udp 传输层
ftp dns http 应用层

### socket

### https和http

### 常见端口号

### 常见状态号及其意义

### 死锁问

### 进程状态

### 进程通信方式

### 线程池，进程池

### 子进程，僵尸孤儿进程线程
