# 算法题集锦

## 排序及相关

### 快速排序


```

def partition(nums, start, end): # 注意，这个函数的start和end表示要partition的段，所以所有操作都在要在statr和end上做

    if len(nums) <= 0 or start < 0 or end >= len(nums):  # 检查下表是否合法
        return -1

    base = nums[end]  # 直接选取末尾数字作为基准点

    small = start-1  # small初始化为前一格

    for i in range(start, end): # start~end-1，end已经是基准点了
        if nums[i] < base:
            small += 1  # 先移动，在交换
            if small != i:
                nums[i], nums[small] = nums[small], nums[i]

    small += 1  # small指向第一个比base大的数字
    nums[end], nums[small] = nums[small], nums[end]
    return small


def quickSort(nums, start, end):

    if start == end:  # 递归出口条件是，start和end重合了
        return

    index = partition(nums, start, end)  # 先做partition，再递归quicksort

    if index > start:
        quickSort(nums, start, index-1)
    if index < end:
        quickSort(nums, index+1, end)
```

### 寻找第k小的元素和前k小的元素


```
def findKthSmall(nums, k):

    k -= 1  # 第k大的数，实际上在数组中是k-1那个位置的数
    start = 0
    end = len(nums) - 1
    index = partition(nums, start, end)
    while index != k:  # 注意这里是循环，知道找到index是k为止
        if index < k:
            index = partition(nums, index + 1, end) # 这里并没有递归，都是在这个函数调用partition
        if index > k:
            index = partition(nums, start, index-1)
    return nums[index]


def findKSmall(nums, k):

    k -= 1
    start = 0
    end = len(nums) - 1
    index = partition(nums, start, end)
    while index != k:
        if index < k:
            index = partition(nums, index + 1, end)
        if index > k:
            index = partition(nums, start, index - 1)
    ans = []
    for i in range(start, index+1):
        ans.append(nums[i])
    return ans
```
注意：如果是找前k大或者第k大的元素时，只需要变动partition中if nums[i] < base小于号即可。


### 归并排序


### 逆序对
> 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P

简单思路是，挨个遍历数组中的元素，每遍历到一个元素之后和后面的元素再逐一比较，这样的复杂度是O(n^2)。
这里时间都花费在了逐一比较上，这样一个个找逆序对显然是比较耗时的。归并排序的思路就是一次性的找出一串来，所以复杂度会低很多，本质就是归并排序的复杂度O(nlogn)。
首先写一个归并排序，只需要做一丁点修改就可以找出逆序对。归并排序假设左右两个子数组都是有序的，然后再merge成一个大的数组，在merge的过程中，如果前面子数组中某一元素的比后面子数组的某个元素大，那么他肯定后面子数组这个元素之前的所有数都要大，也就是都形成了逆序对，这样一来，一次性就找出了一串逆序对，而不是一个个的找。
另外注意，我们一边找逆序对，一边还要排序，这样做是为了防止重复找已经找到的逆序对。

```

int merge(vector<int> &data, int start, int mid, int end)
{
    vector<int> tmp;
    int i = start;
    int j = mid+1; // 右半部子数组开头是mid+1，因为下面右半部子数组不包含mid
    int cnt = 0;

    while(i <= mid && j <= end)
    {
        if(data[i] <= data[j])
        {
            tmp.push_back(data[i]);
            i++;
        }
        else {
            cnt += j-mid; // 逆序对，从j开始一直到第二个子数组的头部，都够成了逆序对
            tmp.push_back(data[j]);
            j++;
        }
    }

    // 剩余的子数组merge到tmp
    while(i <= mid)
    {
        tmp.push_back(data[i]);
        i++;
    }

    while (j <= end)
    {
        tmp.push_back(data[j]);
        j++;
    }

    for(i=0; i<tmp.size(); i++) // 还需要将排序好的数组复制回原数组
        data[start+i] = tmp[i];

    return cnt;

}

int mergeSort(vector<int> &data, int start, int end)
{
    int cnt = 0;
    if(start < end)
    {
        int mid = (start + end)/2;

        cnt += mergeSort(data, start, mid); //左半部分 包含mid

        cnt += mergeSort(data, mid+1, end); //右半部分 不包含mid

        cnt += merge(data, start, mid, end); //合并两部分，并计算数量

    }

    return cnt;

}


int InversePairs(vector<int> &data)
{
    return mergeSort(data, 0, data.size()-1);
}

```


python版本


```
def merge(nums, start, mid, end):

    i = start
    j = mid + 1
    tmp = []
    cnt = 0

    while i <= mid and j <= end:
        if nums[i] > nums[j]:
            cnt += j-mid
            tmp.append(nums[j])
            j += 1
        else:
            tmp.append(nums[i])
            i += 1

    while i <= mid:
        tmp.append(nums[i])
        i += 1

    while j <= end:
        tmp.append(nums[j])
        j += 1

    for i in range(len(tmp)):
        nums[start+i] = tmp[i]
    return cnt


def mergeSort(nums, start, end):
    cnt = 0
    if start < end:
        mid = (start + end) // 2
        cnt += mergeSort(nums, start, mid)
        cnt += mergeSort(nums, mid+1, end)
        cnt += merge(nums, start, mid, end)
    return cnt

```

## 二叉树及其相关

### 树的遍历

递归形式


```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


# 先序
class Solution:
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        ans = []
        def preorder(node):
            if node == None:
                return
            ans.append(node.val)
            preorder(node.left)
            preorder(node.right)
        
        ans = []
        preorder(root)
        
        return ans
        
# 中序
class Solution:
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        
        def inOrder(node,ans):
            if node == None:
                return
            inOrder(node.left, ans)
            ans.append(node.val)
            inOrder(node.right, ans)
        ans = []
        inOrder(root, ans)
        return ans
# 后序    
class Solution:
    def postorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        def postorder(node, ans):
            if node == None:
                return
            postorder(node.left, ans)
            postorder(node.right, ans)
            ans.append(node.val)
            
        ans = []
        postorder(root, ans)
        return ans
```

note:
1. 先序中序后序的区别在于什么时候访问根节点
2. 递归理解，以先序遍历为例，先访问根绝点，加入结果list，然后把整个左子树扔进函数里递归调用，递归出口是访问到叶子节点没有左右孩子时，逐层返回。
3. ans随着函数递归调用也可以，设置成全局变量也可以
4. 注意递归的出口条件，空节点时返回


非递归形式


```
# 先序
class Solution:
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        stack = []
        stack.append(root)
        ans = []
        
        while len(stack) != 0:
            p = stack.pop()
            if p != None:
                ans.append(p.val)
                stack.append(p.right)
                stack.append(p.left)
        
        return ans

# 中序    
class Solution:
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        
        stack = []
        ans = []
        
        p = root
        
        while p or len(stack) != 0:
            
            while p:
                stack.append(p)
                p = p.left
            
            p = stack.pop()
            ans.append(p.val)
            p = p.right
            
        return ans
        
# 后序        
class Solution:
    def postorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if root == None:
            return []
        stack = [root]
        pre = None
        ans = []
        
        while len(stack) > 0:
            cur = stack[-1]
            if (cur.left == None and cur.right == None) or (pre != None and (pre == cur.left or pre == cur.right)):
                ans.append(cur.val)
                stack.pop()
                pre = cur
            else:
                if cur.right:
                    stack.append(cur.right)
                if cur.left:
                    stack.append(cur.left)
        return ans
        
        
```
https://blog.csdn.net/xiaominkong123/article/details/51567437
https://www.cnblogs.com/SHERO-Vae/p/5800363.html
https://blog.csdn.net/ryjflyshy/article/details/78250348

### 逐层遍历树

广度搜索


```
class Solution:
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if root == None:
            return []
        ans = []
        layer = [root]
        while len(layer) != 0:
            value_layer = []
            next_layer = []
            for node in layer:
                value_layer.append(node.val)
                if node.left != None:
                    next_layer.append(node.left)
                if node.right != None:
                    next_layer.append(node.right)
            ans.append(value_layer)
            layer = next_layer
        return ans
            
```

note：
1. 维护一个layer层，每次都要在这个list中去node遍历
2. layer层每次内部循环结束后，都要更新成下一层
3. 如果node是叶子节点，下一层就没有东西加入next_layer，外层大循环的结束条件是，某一层没有任何node了。


### Path Sum 

https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/537/

bottom up解法
```
class Solution:
    def hasPathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        """
        
        def dfsBottomUp(node, sumNum, sum):
            
            sumNum += node.val
            
            if node.left == None and node.right == None:
                return True if sumNum == sum else False
            
            ans1 = ans2 = False
            if node.left != None:
                ans1 = dfsBottomUp(node.left, sumNum, sum)
            if node.right != None:
                ans2 = dfsBottomUp(node.right, sumNum, sum)
            return ans1 or ans2
        
        if root == None:
            return False
        ans = dfsBottomUp(root, 0, sum)
        return ans
                
```

note：
1. 遍历到叶子节点时，开始比较和，并把结果逐层上交。
2. 每一个节点都会收到来自于左右子树两个不同的结果，只有其中有一个是true就可以，所以使用or操作
3. 这里不需要使用回溯法，因为每个节点在调用函数的一开始加上本节点的value，各个节点之间互不影响。
4. bottom up解法的关键在于结果是在最上层给出的，因此要处理好本层和下层返还给的结果的关系，处理之后继续向上层递交结果。


top down解法

```
class Solution:
    
    def __init__(self):
        self.ans = False
    
    def hasPathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        """
        
        def dfsTopDown(node, sumNum, sum):
            
            sumNum += node.val
            
            if node.left == None and node.right == None:
                if sumNum == sum:
                    self.ans = True
                return
            
            if node.left != None:
                dfsTopDown(node.left, sumNum, sum)
            if node.right != None:
                dfsTopDown(node.right, sumNum, sum)
        
        if root == None:
            return False
        dfsTopDown(root, 0, sum)
        return self.ans
```

note：
1. top down的精髓在于要设置一个全局的结果变量，当从上向下算到最后的时候更新这个结果变量。注意，这个结果变量必须是全局的，不能跟随一起递归。


- 最大深度


top down解法
```
class Solution:
    
    def __init__(self):
        self.maxDep = 0
    
    
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def maxDepthCore(node, depth):

            if node == None:
                return 
            if node.left == None and node.right == None:
                self.maxDep = max(depth, self.maxDep)
            maxDepthCore(node.left, depth+1)
            maxDepthCore(node.right, depth+1)
             
        ans = maxDepthCore(root, 1)
        return self.maxDep
        
```


bottom up解法


```
class Solution(object):
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        d = 0
        def dfs(root,d):
            if root == None:
                return d
            d1 = dfs(root.right,d+1)
            d2 = dfs(root.left,d+1)
            return max(d1,d2)
        d = dfs(root,d)
        return d
```

这两个方法几乎和上一个题完全一样。


### 对称树

https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/536/

```
class Solution:
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        def dfs(node1, node2):
            
            if node1 == None and node2 == None:
                return True
            
            elif node1 == None or node2 == None:
                return False
            
            if node1.val != node2.val: # 注意这里不需要判断相等情况，即使相等，也并不能说明是镜像的，一定要判断到叶子节点为止
                return False
            
            ans1 = dfs(node1.left, node2.right)
            ans2 = dfs(node1.right, node2.left)
            
            return ans1 and ans2
        
        if root == None:
            return True
        ans = dfs(root.left, root.right)
        return ans
```

bottom up的方法，ans就是不断向上递交的结果。


### 由遍历结果构造树

已知后序和中序构造二叉树


```
class Solution:
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """
        
        if len(postorder) == 0:
            return None
        
        rootNode = postorder[-1]
        
        splitIndex = 0
        for i in range(len(inorder)):
            if inorder[i] == rootNode:
                splitIndex = i

        left_inorder = inorder[:splitIndex]
        right_inorder = inorder[splitIndex+1:]
        left_postorder = postorder[:splitIndex]
        right_postorder = postorder[splitIndex:-1]
        
        left_root = self.buildTree(left_inorder, left_postorder)
        right_root = self.buildTree(right_inorder, right_postorder)
        
        root = TreeNode(rootNode)
        root.left = left_root
        root.right = right_root
        
        return root
```

已知前序和中序构造树


```
class Solution:
    def buildTree(self, preorder, inorder):
        """
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        """
        if len(preorder) == 0 or len(inorder) == 0:
            return None
        
        rootNode = preorder[0]
        
        splitIndex = 0
        for i in range(len(inorder)):
            if inorder[i] == rootNode:
                splitIndex = i
        
        left_inorder = inorder[:splitIndex]
        right_inorder = inorder[splitIndex+1:]
        left_preorder = preorder[1:1+splitIndex]
        right_preorder = preorder[splitIndex+1:]
        
        
        left_root = self.buildTree(left_preorder, left_inorder)
        right_root = self.buildTree(right_preorder, right_inorder)
        
        root = TreeNode(rootNode)
        root.left = left_root
        root.right = right_root
        
        return root
```

note:
1. 这两种都必须有中序遍历，否则结果不是确定的
2. 两种思路极为接近，都是在本层找出root，然后把原来的遍历按照root划开，分别递归调用函数
3. 递归出口在遍历数组没有元素了为止
4. 属于bottom up方案，底层攒好树结构后向上层返回子树的root，上层把子树的root加挂在自己的下面后继续向上递交。


### Populating Next Right Pointers in Each Node

https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/994/

这个题有多种解法，题目要求要在O(1)空间复杂度内做出。

方法一：递归

```
class Solution:
    # @param root, a tree link node
    # @return nothing
    def connect(self, root):
        if root == None:
            return None
        if root.left:
            root.left.next = root.right
        if root.right:
            if root.next:
                root.right.next = root.next.left
            else:
                root.right.next = None
        self.connect(root.left)
        self.connect(root.right)
        
```
这个方法的思路是，拿到一个node，把下一层的node串起来。由于是完全二叉树，左孩子有则必有右孩子，所有left可以直接next指向right。至于right，要先看父节点的next有没有，如果有，right的next就指向父节点next的left，否则指向none。

完成一个节点后，开始递归调用，把这个节点的左右孩子传入进去即可。

方法二：迭代


```
class Solution:
    # @param root, a tree link node
    # @return nothing
    def connect(self, root):
        
        if root == None:
            return
        
        start = root
        cur = None
        
        while(start.left):
            
            cur = start
            
            while(cur):
                cur.left.next = cur.right
                if cur.next:
                    cur.right.next = cur.next.left
                    
                cur = cur.next # 后移遍历本层的所有node
                
            start = start.left # 向下继续找最左侧开始的地方
```

这个是上面递归的迭代版本，是真正做到了O(1)复杂度的。
整体思路为，外层循环一直在左侧找开始，内层循环和上面的递归类似，只不过多了一个cur=cur.next用来不断后移这一层的cur

方法三：队列


```
class Solution:
    # @param root, a tree link node
    # @return nothing
    def connect(self, root):
        
        queue = [root, None]
        while True:
            cur = queue[0]
            queue.pop(0)
            if cur:
                cur.next = queue[0]
                if cur.left:
                    queue.append(cur.left)
                if cur.right:
                    queue.append(cur.right)
            else:
                if len(queue) == 0 or queue[0] == None:
                    return 
                queue.append(None)
```
这个方法不太符合要求，因为开辟了多余的空间。
此方法巧妙之处在于使用了none为分割标记，这样就可以区分出层了。当队列中取出的元素时none时，代表上一层所有节点已经全部用完，不能再继续扩展了，因此队列中要加入一个none表示下层的扩展结束。

### Populating Next Right Pointers in Each Node II

https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/1016/

```
class Solution:
    # @param root, a tree link node
    # @return nothing
    def connect(self, root):
        
        dummy = TreeLinkNode(0)
        curr = dummy
        
        while(root):
            if root.left:
                curr.next = root.left
                curr = curr.next
            if root.right:
                curr.next = root.right
                curr = curr.next
            root = root.next
            if root == None:
                curr = dummy
                root = dummy.next
                dummy.next = None
```

note：
1. 这里不再是完全二叉树，因此存在左孩子有右孩子就一定有这个条件了。
2. 设置一个dummy来记录每一层的开始位置，dummy.next指向每一层的第一个node
3. 注意，进入循环之前，dummy和curr是一个东西，因此curr.next=root.left/right实际上已经标明dummy.next是root.left或者right了,之后curr = curr.next，curr不再是dummy，因此dummy的就保住了。
4. root不断后移，直到none后，说明本层结束，root要更新成下一层的开始，也就是之前保住的dummy.next，然后把它清空
5. 主体思路还是遍历一层，连接他的下一层，和之前差别不大。


### 最低公共祖先


```
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        
        if root == None or root == p or root == q:
            return root
        
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        
        if left and right:
            return root
        else:
            if left == None:
                return right
            if right == None:
                return left
```

### Smallest Subtree with all the Deepest Nodes

> Given a binary tree rooted at root, the depth of each node is the shortest distance to the root.
> A node is deepest if it has the largest depth possible.
> Return the node with the largest depth such that it contains all the deepest nodes in it's subtree.

```
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    
    
    def subtreeWithAllDeepest(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        
        d = {}
        
        def dfs(node, d, dep):
            
            if node.left == None and node.right == None:
                d[node] = dep
                return node
            
            if node.left == None:
                return dfs(node.right, d, dep+1)
            
            if node.right == None:
                return dfs(node.left, d, dep+1)
            
            leftAns = dfs(node.left, d, dep+1)
            rightAns = dfs(node.right, d, dep+1)
            
            if d[leftAns] == d[rightAns]:
                d[node] = d[leftAns]
                return node
            else:
                if d[leftAns] > d[rightAns]:
                    return leftAns
                else:
                    return rightAns
            
        ans = dfs(root, d, 1)
        return ans
```
note：
1. 这是一道bottom up和top down结合的题目
2. 使用一个字典记录下叶子node的深度，注意，这里只有叶子node才有可能是最大深度node
3. 左右两边同时递归，递归的结果是，如果左右子树返回的节点深度一样，说明当前节点包含了他们，因此在字典中更新本层节点到该深度，向上返回
4. 如果深度不一样，则返回那个更大的




## 哈希相关

### hash set

#### Happy Number

https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1131/


```
class Solution:
    def isHappy(self, n):
        """
        :type n: int
        :rtype: bool
        """
        strNum = str(n)
        sum = 0
        hashset = set()
        while True:
            for char in strNum:
                sum += int(char)*int(char)
            if sum == 1:
                return True
            elif sum in hashset:
                return False
            else:
                hashset.add(sum)
                strNum = str(sum)
                sum = 0
```
Note:
本题关键在于如何判断陷入了死循环。显然，如果在计算过程中遇到了之前就计算得到的结果，那么就会陷入死循环，因此维护一个set，记录已经出现的sum，后面一一比较即可。

### two sum


```
class Solution:
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        
        hashmap = {}
        for index, num in enumerate(nums):
            other = target-num
            if other in hashmap:
                return [hashmap[other], index]
            else:
                hashmap[num] = index
```

Note:
1. hashmap比hashset多一个好处在于，他可以储存额外信息，这个题目中index就是额外信息。如果不返回index，只需要判断是否有这样的加和对存在，hashset即可。
2. 用hashmap减少一层循环的工作量，先算出当前num的补数，然后去hashmap里查有没有对应的，有就提出他的index，没有就把当前num加入hashmap


## three sum


```
class Solution:
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        nums.sort()
        
        ans = []
        
        for i in range(len(nums)):
            
            if nums[i] > 0:  # 若此数就是正数，后面就不可能和它凑成0，直接结束
                break
                
            if i > 0 and nums[i] == nums[i-1]:  # i和前面的数一样，跳过本次遍历
                continue
            
            target = -nums[i]
            
            start = i+1
            end = len(nums) - 1
            
            while start < end:   # 没有等号，有等号一个数字就会被使用2次
                if nums[start] + nums[end] == target:
                    ans.append((nums[i], nums[start], nums[end]))
                    while start < end and nums[start] == nums[start+1]:  # 跳过重复数字
                        start += 1
                    while start < end and nums[end] == nums[end-1]:
                        end -= 1
                    # 还要再走一步，走到非重复部分
                    start += 1
                    end -= 1
                elif nums[start] + nums[end] < target:
                    start += 1
                else:
                    end -= 1
                    
        return ans
                
        
        
```
### 3Sum Closest

```
class Solution:
    def threeSumClosest(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        
        mindiff = 999999999
        
        nums.sort()  # 双指针一定要要先排序
        
        for i in range(len(nums)):
            
            start = i+1
            end = len(nums) - 1
            
            while start < end:   # 不要等号，否则会一个数字选两次
                
                sumNum = nums[i] + nums[start] + nums[end]
                tmp = sumNum - target
                
                if abs(tmp) < abs(mindiff):
                    mindiff = tmp
                    
                if sumNum == target:
                    return target
                elif sumNum > target:
                    end -= 1
                else:
                    start += 1
        return mindiff + target
```
### 4Sum

```
class Solution:
    def fourSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        nums.sort()
        n = len(nums)
        ans = []
        
        for i in range(n):
            
            if i > 0 and nums[i] == nums[i-1]:  # 去重措施
                continue
                
            for j in range(i+1, n):
                
                if j > i+1 and nums[j] == nums[j-1]:  # 去重措施
                    continue
                    
                start = j + 1
                end = n - 1
                
                while start < end:
                    
                    sumNum = nums[i] + nums[j] + nums[start] + nums[end]
                    
                    if sumNum == target:
                        ans.append((nums[i] , nums[j] , nums[start] , nums[end]))
                        # 去重措施
                        while start < end and nums[start] == nums[start+1]:
                            start += 1
                        while start < end and nums[end] == nums[end-1]:
                            end -= 1
                        # 因为有多个可能答案，找到一个后两个指针同时移动，还要继续遍历
                        start += 1
                        end -= 1
                        
                    elif sumNum < target:
                        start += 1
                    else:
                        end -= 1
        return ans
```
note:
1. 这些题目基本都可以用双指针法来求解，固定其中一个或者两个数字，最后两个数字由双指针在线性时间内扫出即可。
2. 注意在循环和双指针内部的去重操作，跳过重复的数字即可

###  4Sum II

https://leetcode.com/explore/learn/card/hash-table/187/conclusion-hash-table/1134/

```
class Solution:
    def fourSumCount(self, A, B, C, D):
        """
        :type A: List[int]
        :type B: List[int]
        :type C: List[int]
        :type D: List[int]
        :rtype: int
        """
        
        d1 = {}
        for num1 in A:
            for num2 in B:
                sumNum = num1+num2
                if sumNum in d1:
                    d1[sumNum] += 1
                else:
                    d1[sumNum] = 1
        d2 = {}
        for num1 in C:
            for num2 in D:
                sumNum = num1+num2
                if sumNum in d2:
                    d2[sumNum] += 1
                else:
                    d2[sumNum] = 1
        
        ans = 0
        for key,val in d1.items():
            if -key in d2:
                ans += d2[-key] * val
        
        return ans
```
note:
1. 暴力思路是四重循环
2. 优化一步是在最后一重循环用hash，复杂度n^3
3. 当前做法是，两个list求一次和，存到hashmap里，然后检查另一个hashmap里是否有相反数
4. 如果有，则需要把两边记录的频数相乘，这是乘法原理，相当于sum=key有n中可能，另外一个hash对的-key的有m种可能，总的加起来和为0的可能输就是m*n


###  Isomorphic Strings


```
class Solution:
    def isIsomorphic(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: bool
        """
        hashmap = {}
        n = len(s)
        for i in range(n):
            if s[i] not in hashmap:
                hashmap[s[i]] = t[i]
            else:
                if hashmap[s[i]] != t[i]:
                    return False
        hashmap.clear()
        for i in range(n):
            if t[i] not in hashmap:
                hashmap[t[i]] = s[i]
            else:
                if hashmap[t[i]] != s[i]:
                    return False
        return True
```

note：
1. 这里对应关系是一个双向映射关系，因此需要确保从s到t和t到s都是一一映射
2. 两种办法，一种是走两遍循环，用一个hashmap，一个是开两个hashmap，走一遍循环。


### Minimum Index Sum of Two Lists

https://leetcode.com/explore/learn/card/hash-table/184/comparison-with-other-data-structures/1177/


```
class Solution:
    def findRestaurant(self, list1, list2):
        """
        :type list1: List[str]
        :type list2: List[str]
        :rtype: List[str]
        """
        
        hashmap = {}
        ans = []
        
        for index, item in enumerate(list1):
            hashmap[item] = index
            
        sumMin = 1000000
        for index, item in enumerate(list2):
            if item in hashmap:
                sumIndex = index+hashmap[item]
                if sumIndex < sumMin:
                    sumMin = sumIndex
                    ans.clear()
                    ans.append(item)
                elif sumIndex == sumMin:
                    ans.append(item)
        return ans
                      
```

note
1. 找公共集合，而且要找index之和最小的，因此需要用hashmap记录额外信息index。
2. 应该一遍循环找sumMin，一遍循环确定公共集合，因为公共的集合不一定唯一。
3. 一遍循环搞定，一边循环一边找sumMin，当发现了比当前sumMin还小的组合的时候，意味着ans里记录的答案全错，clear后重新记录答案。


### First Unique Character in a String


```
class Solution:
    def firstUniqChar(self, s):
        """
        :type s: str
        :rtype: int
        """
        if s == "":
            return -1
        hashmap = {}
        for char in s:
            if char in hashmap:  
                hashmap[char] += 1
            else:
                hashmap[char] = 1
        
        for index, char in enumerate(s):
            if hashmap[char] == 1:
                return index
        
        return -1
```
note：
1. hashmap记录的额外信息是字母出现的频数


### Intersection of Two Arrays II

https://leetcode.com/explore/learn/card/hash-table/184/comparison-with-other-data-structures/1178/


```
class Solution:
    def intersect(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        hashmap = {}
        for num in nums1:
            if num in hashmap:
                hashmap[num] += 1
            else:
                hashmap[num] = 1
        
        ans = []
        for num in nums2:
            if num in hashmap and hashmap[num] != 0:
                ans.append(num)
                hashmap[num] -= 1
        
        return ans
```

note：
1. 和上一个题类似，用hashmap记录频数这一额外信息。

类似题：Jewels and Stones

https://leetcode.com/explore/learn/card/hash-table/187/conclusion-hash-table/1136/


```
class Solution:
    def numJewelsInStones(self, J, S):
        """
        :type J: str
        :type S: str
        :rtype: int
        """
        counter = collections.Counter()
        for stone in S:
            counter[stone] += 1
        
        ans = 0
        for jewel in J:
            if jewel in counter:
                ans += counter[jewel]
        return ans
```



### Contains Duplicate II

https://leetcode.com/explore/learn/card/hash-table/184/comparison-with-other-data-structures/1121/

```
class Solution:
    def containsNearbyDuplicate(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: bool
        """
        hashmap = {}
        for index, num in enumerate(nums):
            if num in hashmap and abs(hashmap[num] - index) <= k:
                return True
            else:
                hashmap[num] = index
        return False
```
note:
1. hashmap记录index信息，每次遍历去hashmap中查是否有这个数，如果有，是否满足下标差小于k的要求。

### Group Anagrams

https://leetcode.com/explore/learn/card/hash-table/185/hash_table_design_the_key/1124/

```
class Solution:
    def groupAnagrams(self, strs):
        """
        :type strs: List[str]
        :rtype: List[List[str]]
        """
        
        
        def strSort(word):
            return "".join((lambda x:(x.sort(),x)[1])(list(word)))
        
        sortedWords = []
        ans = {}
        for word in strs:
            sortedWords.append(strSort(word))
        
        for i in range(len(strs)):
            if sortedWords[i] not in ans:
                ans[sortedWords[i]] = [strs[i]]
            else:
                ans[sortedWords[i]].append(strs[i])

        return list(ans.values())
```
note:
1. 关键在于要把原有字符串排序，这样不同的组合就能映射到同一个key了
2. dict可以使用list作为value，但是key好像不能hash
3. 扫描的是排序后的字符串数组，但是实际上装入的是原始字符串数组。


### Find Duplicate Subtrees

https://leetcode.com/explore/learn/card/hash-table/185/hash_table_design_the_key/1127/


```
class Solution:
    def findDuplicateSubtrees(self, root):
        """
        :type root: TreeNode
        :rtype: List[TreeNode]
        """
        counter = collections.Counter()
        ans = []
        
        def collect(node):
            if not node:
                return '#'
            key = "{}, {}, {}".format(node.val, collect(node.left), collect(node.right))
            counter[key] += 1
            if counter[key] == 2:
                ans.append(node)
            return key
        
        collect(root)
        
        return ans
```
note
1. 这个题的难度在于如何选择一种key可以唯一表示一棵树，另外如何遍历到所有的subtree。
2. key可以选择序列化tree的操作，具体参考链接 https://leetcode.com/problems/find-duplicate-subtrees/solution/
3. 如何遍历选择dfs，这是一个bottom up的过程，当遍历到叶子节点，就返回#，交给上层，上层拿到下层的返回序列化key，构造自己subtree的key，然后加入hashmap。同时检查hashmap是否出现重复。
4. hashmap采用了collection的counter，更多信息参考 https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001411031239400f7181f65f33a4623bc42276a605debf6000


解法二：

```
class Solution:
    def findDuplicateSubtrees(self, root):
        """
        :type root: TreeNode
        :rtype: List[TreeNode]
        """
        trees = collections.defaultdict()
        trees.default_factory = trees.__len__
        counter = collections.Counter()
        ans = []
        def lookup(node):
            if node:
                uid = trees[node.val, lookup(node.left), lookup(node.right)]
                counter[uid] += 1
                if counter[uid] == 2:
                    ans.append(node)
                return uid
        
        lookup(root)
        return ans
        
```
note：
1. 类似于上面的解法，也是要找一个合适key，这次找的是node.val node.left和node.right
2. 这个方法的巧妙在于，上面的方法要形成一个key，复杂度是O（n^2）,因为需要遍历一下tree，还要把每个subtree序列化一遍。这个方法优化了这一步，直接用一个hash表示subtree，每个subtree仅仅和孩子节点的key有关。因此复杂度是O（n）
3. 注意node一定要是val，只需要val一样，subtree就认为是相同的，如果是加入node对象，每一个node都是不同的，也就没有答案了。
4. 这里还是bottom up的思路，底层subtree用自己的left和right以及自身的val形成了一个唯一的uid，交到上层，上层继续用这个形成自己的uid


### Longest Substring Without Repeating Characters


```
class Solution:
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        usedChar = {}
        maxlen = 0
        start = 0
        for i in range(len(s)):
            if s[i] in usedChar and start <= usedChar[s[i]]:
                start = usedChar[s[i]]+1
            else:
                maxlen = max(maxlen, i-start+1)
            usedChar[s[i]] = i
        return maxlen
```
note：
1. 需要使用hashmap来记录index这个额外信息。
2. 如果一个字符已经被使用过，那么下一次就要从被使用过的字符的下一个继续搜索。
3. 循环每次都要记录最新字符出现的位置

### Top K Frequent Elements


```
class Solution(object):
    def topKFrequent(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        
        d = {}
        ans = []
        for num in nums:
            if num not in d:
                d[num] = 1
            else:
                d[num] += 1
        
        sortD = sorted(d.items(), key=lambda x:x[1], reverse=True)
        for i in range(k):
            ans.append(sortD[i][0])
        return ans
        
```
note：
1. 简单题，hashmap统计频数即可，但是要注意怎么对字典排序。



## 栈 stack

### Score of Parentheses

Given a balanced parentheses string S, compute the score of the string based on the following rule:

- () has score 1
- AB has score A + B, where A and B are balanced parentheses strings.
- (A) has score 2 * A, where A is a balanced parentheses string.



```
class Solution:
    def scoreOfParentheses(self, S):
        """
        :type S: str
        :rtype: int
        """
        stack = []
        
        for c in S:
            if c == "(":
                stack.append(-1) # 以-1作为标记
            else:
                cur = 0
                while(stack[-1] != -1):  # 把配对之前的分数都加起来
                    cur += stack.pop()
                stack.pop()  # 跑掉当前）配对的（代表的-1
                if cur == 0:  # 如果没有中间的分数，证明是直接配对的括号，1分
                    stack.append(1)
                else:
                    stack.append(cur*2)  # 用中间配对的分数，加倍
        
        ans = 0
        while len(stack) != 0:  # 遍历分数栈，可能会有多个分散的括号组合，因此加和
            ans += stack.pop()
        
        return ans
```

### Valid Parentheses

```
class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        d = {'(':')','{':'}','[':']'}
        stack = []
        n = len(s)
        for i in range(n):
            if s[i] == '(' or s[i] == '[' or s[i] == '{':
                stack.append(s[i])
            if s[i] == ')' or s[i] == ']' or s[i] == '}':
                if len(stack) == 0:
                    return False
                elif d[stack[-1]] == s[i]:
                    del stack[-1]
                else:
                    return False
        if len(stack) == 0:
            return True
        else:
            return False
```


## 二叉搜索树 BST

### Validate Binary Search Tree

解法一

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        import sys
        def bottomup(node, minNum, maxNum):
            if node == None:
                return True
            if node.val <= minNum or node.val >= maxNum:
                return False
            left = bottomup(node.left, minNum, node.val)
            right = bottomup(node.right, node.val, maxNum)
            return left and right
        
        ans = bottomup(root, -sys.maxsize -1, sys.maxsize)
        return ans
```

note:
1. bottom up思路，从叶子节点向上逐层提交结果。
2. 验证的时候要维护最大值和最小值，递归更新的时候，本层的node节点的值对于left 子树来说就是最大的，对于right 子树来说就是最小的。
3. 递归的时候检查是否满足BST条件，注意，BST要求左子树所有节点都要比本层node小，右子树所有节点都要比本层node大，而不是仅仅左右节点的值。

解法二


```
class Solution:
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        self.pre = None
        
        def inorder(node):
            
            if node != None:

                if (not inorder(node.left)):
                    return False

                if self.pre != None and self.pre.val >= node.val:
                    return False

                self.pre = node

                return inorder(node.right)
            
            return True
        
        ans = inorder(root)
        return ans
```
note：
1. 采用中序遍历的思路，BST的中序遍历应该是一个递增的数组，这里题目也排除了相等关系，因此不会有歧义。
2. 不开数组也可以做，中序遍历依次比较前一个和当前节点的大小关系，如果违反了就判定为false

### Binary Search Tree Iterator

https://leetcode.com/explore/learn/card/introduction-to-data-structure-binary-search-tree/140/introduction-to-a-bst/1008/

```

class BSTIterator(object):
    def __init__(self, root):
        """
        :type root: TreeNode
        """
        self.stack = []
        p = root
        while p:
            self.stack.append(p)
            p = p.left
        

    def hasNext(self):
        """
        :rtype: bool
        """

        return len(self.stack) != 0
        

    def next(self):
        """
        :rtype: int
        """
        
        p = self.stack.pop()
        val = p.val
        
        if p.right:
            p = p.right
            self.stack.append(p)
            p = p.left
            while p:
                self.stack.append(p)
                p = p.left
        
        return val
```
note：
1. 最小的节点一定是最left的，如何在找到left节点后追溯到父节点，使用栈数据结构来存储。
2. stack先沿着最左边left的路径的node入栈
3. next的时候直接弹出栈顶元素，这个就是要返回的节点值，但是注意此时要更新栈，更新的方法是，先看弹出的node有没有right，因为这个已经是left到底了，所以不可能再用left了。如果还没有right，说明是个叶子node，无须更新栈，如果是有right的，继续沿着这个node的left线路入栈

### Search in a Binary Search Tree

递归法

```

class Solution(object):
    def searchBST(self, root, val):
        """
        :type root: TreeNode
        :type val: int
        :rtype: TreeNode
        """
        
        if root == None:
            return
        if root.val == val:
            return root
        elif root.val > val:
            return self.searchBST(root.left, val)
        else:
            return self.searchBST(root.right, val)
```

迭代法


```
class Solution(object):
    def searchBST(self, root, val):
        """
        :type root: TreeNode
        :type val: int
        :rtype: TreeNode
        """
        
        p = root
        while p:
            if p.val == val:
                return p
            elif p.val > val:
                p = p.left
            else:
                p = p.right
        else:
            return None
```

note：
1. 从上向下搜索，如果当前node大于target，左子树中去找，否则右子树去找。


### Insert into a Binary Search Tree

递归法

```
class Solution(object):
    def insertIntoBST(self, root, val):
        """
        :type root: TreeNode
        :type val: int
        :rtype: TreeNode
        """
        
        if root == None:
            root = TreeNode(val)
            return root
        elif root.val < val:
            root.right = self.insertIntoBST(root.right, val)
            return root
        elif root.val > val:
            root.left = self.insertIntoBST(root.left, val)
            return root
```

迭代法


```
class Solution(object):
    def insertIntoBST(self, root, val):
        """
        :type root: TreeNode
        :type val: int
        :rtype: TreeNode
        """
        
        p = root
        if p == None:
            root = TreeNode(val)
            return root
        
        while p:
            if p.val < val:
                if p.right == None:
                    p.right = TreeNode(val)
                    return root
                p = p.right
            else:
                if p.left == None:
                    p.left = TreeNode(val)
                    return root
                p = p.left
```
note:
1. 本质是寻找叶子node，加挂的node一定可以加在某个叶子node上？
2. 如果当前的node值小于要插入的值，而且当前node没有right，所以新的值应该就可以被挂在right上，left分析类似。

### Delete Node in a BST


```
class Solution:
    def deleteNode(self, root, key):
        """
        :type root: TreeNode
        :type key: int
        :rtype: TreeNode
        """
        
        def getsmallest(node):
            p = node
            while p.left:  # 这里必须是left，因为p如果是none停下，就没有val属性了 
                p = p.left
            return p.val
        
        if root == None:
            return None
        
        if root.val == key:
            if root.left == None and root.right == None:
                return None
            elif root.left == None:
                return root.right
            elif root.right == None:
                return root.left
            else:
                root.val = getsmallest(root.right)  # 把当前节点替换成右子树的最小node的值，也就是中序遍历紧跟着的那个值
                root.right = self.deleteNode(root.right, root.val)  # 这一步把替换值传入，为的是把后面这个节点删去
        
        
        elif root.val > key:
            root.left = self.deleteNode(root.left, key)
        
        else:
            root.right = self.deleteNode(root.right, key)
        
        return root
```
note：
1. 分情况讨论，如果要删除的节点没有child，直接删除
2. 如果要删除的node有其中一个child，用child替换这个node
3. 如果两个child都有，需要把subtree里中序遍历里紧跟着这个node的val替换他，然后再去掉这个node。


### Lowest Common Ancestor of a Binary Search Tree


```
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        if root == None:
            return 
        if root.val > max(p.val, q.val):
            return self.lowestCommonAncestor(root.left, p, q)
        elif root.val < min(p.val, q.val):
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root
```
note：
1. 如果当前node的值比p和q都要大，说明这个最低公共祖先肯定在左子树里，右子树分析同理。
2. 这里由于是BST，可以借助这个性质，一般的BT就不可以了。

### Contains Duplicate III

https://leetcode.com/explore/learn/card/introduction-to-data-structure-binary-search-tree/142/conclusion/1013/

```
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
        multiset<long long> bst;
        for (int i = 0; i < nums.size(); ++i) {
            if (bst.size() == k + 1) bst.erase(bst.find(nums[i - k - 1]));
            auto lb = bst.lower_bound(nums[i]);
            if (lb != bst.end() && abs(*lb - nums[i]) <= t) return true;
            auto ub = bst.upper_bound(nums[i]);
            if (ub != bst.begin() && abs(*(--ub) - nums[i]) <= t) return true;
            bst.insert(nums[i]);
        }
        return false;
    }
};
```
note：
1. 维护一个大小为k的二叉搜索树，这个BST相当于一个滑动窗口，其中所有的元素都可以满足下标差距在k内的要求。
2. 检验其中的元素是否满足值大小的要求，这里用到了lower bound和upper bound来搜索。
3. 继续向前滚动，加入新的元素，bst的插入删除惭怍都是logn的复杂度，因此效率很高。


### Kth Largest Element in a Stream

TLE

```
class KthLargest(object):

    def __init__(self, k, nums):
        """
        :type k: int
        :type nums: List[int]
        """
        from heapq import *
        self.heap = nums
        #for num in nums:
        heapify(self.heap)
        self.k = k
        

    def add(self, val):
        """
        :type val: int
        :rtype: int
        """
        from heapq import *
        if len(self.heap) <= self.k:
            heappush(self.heap, val)
        else:
            if val > self.heap[0]:
                heapreplace(self.heap, val)
        return nlargest(self.k, self.heap)[-1]
        


# Your KthLargest object will be instantiated and called as such:
# obj = KthLargest(k, nums)
# param_1 = obj.add(val)
```
note：
1. 维护一个大小为k的heap或者bst，大小超过k前一直把新来的元素加入即可
2. 超过k后，要比较新来的元素和heap中最小的元素的关系，如果比最小元素还小，就不可能是前k大的，因此不加入，满足条件的可以插入。
3. 返回的就是第k大的数字，所有操作都能在logn内完成。
4. 关于堆的简单知识补充 https://www.cnblogs.com/JVxie/p/4859889.html
5. 关于python中heapq补充： https://www.cnblogs.com/chang1203/p/6537345.html

### Balanced Binary Tree


```
class Solution(object):
    def isBalanced(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        def dfs(node):
            
            if node == None:
                depth = 0
                return True, depth
            
            left, leftDep = dfs(node.left)
            right, rightDep = dfs(node.right)
            
            if  left and right:
                diff = abs(leftDep-rightDep)
                if diff <= 1:
                    depth = 1 + max(leftDep, rightDep)
                    return True, depth
            return False, 0  # 注意，这里不能有else，前面两个if都不满足才会触发这一句
            
        ans, depth = dfs(root)
        return ans
```
note：
1. bottom up思路，subtree逐层向上提交自己是否是平衡树的判断结果。
2. 同时向上提交的还有本层的depth，方便上层node来判断自己是不是平衡的。
3. 递归的出口在叶子节点下层，一旦遍历到none，深度设置为0，返回true

### Convert Sorted Array to Binary Search Tree


```
class Solution:
    def sortedArrayToBST(self, nums):
        """
        :type nums: List[int]
        :rtype: TreeNode
        """
        
        def buildTree(nums, low, high):
            
            if low > high:  # 这里不能有等于，当low和high相遇时，mid就是low和high本身的node，这个也要加入到tree中
                return None
            
            mid = (low+high)//2
            root = TreeNode(nums[mid])
            root.left = buildTree(nums, low, mid-1)
            root.right = buildTree(nums, mid+1, high)
            
            return root
        
        return buildTree(nums, 0, len(nums)-1)
```
note：
1. 从数组的二分之一处开始建树，然后递归二分地继续调用这个过程+
2. 



## 链表

### Linked List Cycle

```
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        pfast = head
        pslow = head
        
        if pfast == None:
            return False
        
        while pfast != None and pfast.next != None:
            pfast = pfast.next.next
            pslow = pslow.next
            if pfast == pslow:
                return True
        return False
        
```
note：
1. 思路很简单，快慢指针
2. 注意，fast指针是循环结束的条件，fast一次走两步，因此判断fast本身是不是空以及fast.next是不是空很重要。slow因为比fast慢，因此肯定不会在fast空之前为空。

###  Intersection of Two Linked Lists


```
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def getIntersectionNode(self, headA, headB):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        """
        n1 = 0
        p = headA
        while p != None:
            p = p.next
            n1 += 1
        
        n2 = 0
        p = headB
        while p != None:
            p = p.next
            n2 += 1
        
        p1 = headA
        p2 = headB
        if n1 >= n2:
            for i in range(n1-n2):
                p1 = p1.next
        else:
            for i in range(n2-n1):
                p2 = p2.next
        while (p1 != p2):
            p1 = p1.next
            p2 = p2.next
            
        return p1
        
```
note：
1. 统计一下两个链表的长度，让长的链表node先走多出来那些步，然后两个指针一起走，汇合点就是合并点。


###  Remove Nth Node From End of List

https://leetcode.com/explore/learn/card/linked-list/214/two-pointer-technique/1296/

```
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def removeNthFromEnd(self, head, n):
        """
        :type head: ListNode
        :type n: int
        :rtype: ListNode
        """
        dummy = ListNode(0)
        dummy.next = head
        
        fast = dummy
        slow = dummy
        for i in range(n):
            fast = fast.next
        while fast.next != None:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        
        return dummy.next
```
note：
1. 基本思路是快慢指针，快指针先走n步，然后再和满指针一起走。
2. 快指针停止条件是fast.next为空，此时slow指向的是要移除节点的前一个，这样便于操作。
3. 这里有一个trick，如果要移除头结点，直接做很难处理，此时不妨加入一个哑变量dummy，让他当作头部，这样代码无论移除的是正常节点还是头结点，都是统一的，因此返回dummy.next就好了


### Linked List Cycle II

https://leetcode.com/explore/learn/card/linked-list/214/two-pointer-technique/1214/

```
class Solution(object):
    def detectCycle(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        pfast = head
        pslow = head
        
        if pfast == None:
            return None
        
        step_slow  = 0
        
        while pfast != None and pfast.next != None:
            
            pfast = pfast.next.next
            pslow = pslow.next
            step_slow += 1
            
            if pfast == pslow:
                diff = step_slow
                p1 = head
                p2 = head
                for i in range(diff):
                    p1 = p1.next
                while p1 != p2:
                    p1 = p1.next
                    p2 = p2.next
                return p1         
        else:
            return None
        
```
note：
1. 如果有环，两个指针相遇的时候，pfast应该走的是pslow的两倍
2. 多出来哪一倍，就是环的长度。
3. 此时再设置两个指针，一个指针先走完环的长度，两个指针再一起走，汇合点就是环的起点。


### Reverse Linked List


```

class Solution(object):
    def reverseList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        prev = None
        p = head
        pNewHead = None
        
        while(p != None):
            
            nextNode  = p.next
            if nextNode == None:
                pNewHead = p
            p.next = prev
            prev = p
            p = nextNode
        
        return pNewHead
            
```
1. 翻转链表，写一次忘一次，算了直接背过吧。。。。
2. 设计三个指针，一个之前的，一个当前的，还有一个准备当作新的head
3. 进入循环第一步，拿到下一个node，因为当前的next翻转后就找不到下一个node了
4. 翻转指针后，pre后移，当前的p也要后移


### Remove Linked List Elements

https://leetcode.com/explore/learn/card/linked-list/219/classic-problems/1207/


```
class Solution(object):
    def removeElements(self, head, val):
        """
        :type head: ListNode
        :type val: int
        :rtype: ListNode
        """
        dummy = ListNode(0)
        dummy.next = head
        
        pre = dummy
        p = dummy.next
        
        while p != None:
            if p.val == val:
                pre.next = p.next
                p = pre.next
            else:
                p = p.next
                pre = pre.next
                
        return dummy.next
```
note：
1. 思路是遇到val是目标数的node删除即可。
2. 因为涉及到删除，所以要维护一个pre之前的node
3. 因为可能涉及到删除头结点，为了统一操作，仍然使用dummy 的trick。

### Odd Even Linked List

https://leetcode.com/explore/learn/card/linked-list/219/classic-problems/1208/


```
class Solution(object):
    def oddEvenList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        
        if head == None or head.next == None:
            return head
        
        oddHead = head
        evenHead = head.next
        p1 = oddHead
        p2 = evenHead
        while p2 and p2.next:
            p1.next = p2.next
            p1 = p1.next
            p2.next = p1.next
            p2 = p2.next
        p1.next = evenHead
            
        return oddHead
```

note：
1. 基本思路是，偶数位置穿一串，奇数位置穿一串，然后连起来就可以了
2. p1 = p1.next要首先后移，因为后面p2要继续向后再找一个next，p1这时要跑到p2的后面才行。


###  Palindrome Linked List


```
class Solution(object):
    def isPalindrome(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        
        if head == None:
            return True
        
        fast = head
        slow = head
        
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        
        mid = slow
        pre = None
        newHead = None
        
        while mid != None:
            nextnode = mid.next
            if nextnode == None:
                newHead = mid
            mid.next = pre
            pre = mid
            mid = nextnode
        
        p1 = newHead
        p2 = head
        
        while p1 != None and p2 != None and p1.val == p2.val:
            p1 = p1.next
            p2 = p2.next
        
        return p1 is None
```
note：
1. 基本思路是先找中间点，从中间点开始把后面的翻转，然后从两边向中间比较。
2. 找中点的思路是快慢指针，fast每次2步，slow每次一步，当fast停下时，slow就是中间点。
3. 翻转和上面链表翻转完全一样

### Merge Two Sorted Lists


```
class Solution(object):
    def mergeTwoLists(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        
        p1 = l1
        p2 = l2
        p = None
        if p1 == None:
            return p2
        elif p2 == None:
            return p1
        if p1.val < p2.val:
            p = p1
            p.next = self.mergeTwoLists(p1.next,p2)
        else:
            p = p2
            p.next = self.mergeTwoLists(p1,p2.next)
        return p
        
```
note：
1. 基本思路是，拿出两个链表的头结点，比较大小，把小的取出，作为新的node，后面继续加挂。
2. 后续加挂的操作和之前是一样的，所以是递归的。
3. 考虑其中一个链表走完之后，要返回另一个链表的node

### Add Two Numbers

https://leetcode.com/explore/learn/card/linked-list/213/conclusion/1228/


```
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        
        p1 = l1
        p2 = l2
        
        carry = 0
        
        dummy = ListNode(0)
        lastNode = dummy
        
        while p1 or p2:
            
            if p1 and p2:
                sumNum = p1.val + p2.val
                p1 = p1.next
                p2 = p2.next
            elif p1 == None and p2 != None:
                sumNum = p2.val
                p2 = p2.next
            elif p1 != None and p2 == None:
                sumNum = p1.val
                p1 = p1.next
                
            num = (sumNum+carry) % 10 
            carry = (sumNum+carry) / 10
            
            node = ListNode(num)
            lastNode.next = node
            lastNode = node
        
        if carry != 0:
            node = ListNode(carry)
            lastNode.next = node
            
        return dummy.next
```

note：
1. 首先要检验哪一个链表走到了空
2. 设置进位标志carry
3. 计算到最后如果carry不为0，说明还要拓展一位，最后需要处理这种情况。


### Flatten a Multilevel Doubly Linked List

https://leetcode.com/explore/learn/card/linked-list/213/conclusion/1225/

```
class Solution(object):
    def flatten(self, head):
        """
        :type head: Node
        :rtype: Node
        """

        p = head

        while p:
            nextNode = None
            if p.child:
                nextNode = p.next
                p.child.prev = p
                p.next = self.flatten(p.child) # 把child的链表挂上去
                p.child = None
                
                if nextNode != None:  # 如果child后面有节点
                    cur = p.next      # 走完child链表
                    while cur.next:
                        cur = cur.next
                    cur.next = nextNode  #  把后续链表加挂到child后面
                    nextNode.prev = cur
                cur = nextNode
                
            else:
                p = p.next
            
        return head
```
note：


### Rotate List

https://leetcode.com/explore/learn/card/linked-list/213/conclusion/1295/


```
class Solution(object):
    def rotateRight(self, head, k):
        """
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        """
        
        p = head
        
        if p == None:
            return None
        
        cnt = 0
        while p:
            cnt += 1
            p = p.next
        
        s = k % cnt
        
        if s == 0:
            return head
        
        p1 = head
        p2 = head
        for i in range(s):
            p1 = p1.next
        
        while p1.next:
            p1 = p1.next
            p2 = p2.next
        
        newHead = p2.next
        p2.next = None
        p1.next = head
        
        return newHead
        
```
note：
1. 这里的思路是，先算出链表长度，然后对k对长度取模，取模之后的长度其实就是要把链表后面多少个node搬运到前半部，后面用快慢指针找到搬运的起始点，加挂到前半部即可。
2. 细节，这个方法head为空需要特殊处理
3. 细节，这个方法如果s算出来时0需要特殊处理
4. 快慢指针，循环停止条件是p1.next为空，此时p1停在了最后一个节点上，可以挂上前半部的链表，p2停在了旋转点上，可以拆下来作为新的head


### Copy List with Random Pointer

https://leetcode.com/explore/learn/card/linked-list/213/conclusion/1229/


```
class Solution(object):
    def copyRandomList(self, head):
        """
        :type head: RandomListNode
        :rtype: RandomListNode
        """
        
        d = {}
        if head == None:
            return head
        
        p = head
        while p:
            newNode = RandomListNode(p.label)
            d[p] = newNode
            p = p.next
        
        p = head
        while p:
            d[p].next = d[p.next] if p.next else None
            d[p].random = d[p.random] if p.random else None
            
            p = p.next
        
        return d[head] if head else None
```

note：
1. 基本思路是用一个hashmap把新旧链表对应关系存起来，然后第二遍循环加挂指针关系。
2. d[p].next是新node的指针，是需要加挂的对象，指针指向的应该是新的node，也就是d[p.next]，其中p是老节点，p.next就是老节点的下一个，查找hashmap中就是对应的新节点的下一个了，random同理。


## Array and String

###  Find Pivot Index

https://leetcode.com/explore/learn/card/array-and-string/201/introduction-to-array/1144/


```
class Solution:
    def pivotIndex(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        total = sum(nums)
        
        ind = 0
        indsum = 0
        for ind in range(0,len(nums)):
            rightsum = total - nums[ind] - indsum
            if indsum == rightsum:
                return ind
            indsum += nums[ind]
        
        return -1
```
note：
1. 如果遍历每个位置，然后再算两边的和，复杂度是n^2
2. 应该先求出总和，维护一个左边和，右边和可以用总和减出来，复杂度就是n了


### Largest Number At Least Twice of Others

https://leetcode.com/explore/learn/card/array-and-string/201/introduction-to-array/1147/

```
class Solution:
    def dominantIndex(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        
        maxNum = max(nums)
        index = 0
        for i in range(len(nums)):
            if nums[i] == maxNum:
                index = i
                del nums[i]
                break
        if len(nums) == 0:
            return index
        else:
            secondMaxNum = max(nums)
            if maxNum >= 2*secondMaxNum:
                return index
            else:
                return -1
        
```
note：
1. 找出最大值，如果最大值是次大值的两倍就满足要求
2. 找出最大值，去掉最大值，再找的max就是次大的。
3. 注意找出最大值以后并去掉，list可能为空


### Plus One


```
class Solution:
    def plusOne(self, digits):
        """
        :type digits: List[int]
        :rtype: List[int]
        """
        carry = 0
        ans = []
        for i in range(0, len(digits))[::-1]:
            print(i)
            if  i == len(digits)-1:
                tmp = (digits[i]+1)%10
                carry = (digits[i]+1)//10
                ans.append(tmp)
                print(tmp)
            else:
                tmp = (digits[i]+carry)%10
                carry = (digits[i]+carry)//10
                ans.append(tmp)
        if carry > 0:
            ans.append(carry)
        ans = ans[::-1]
        return ans
        
```
note：
1. 大模拟，没什么可说的，注意最后的进位即可。


### Pascal's Triangle


```
class Solution:
    def generate(self, numRows):
        """
        :type numRows: int
        :rtype: List[List[int]]
        """
        
        if numRows == 0:
            return []
        
        if numRows == 1:
            return [[1]]
        
        res = []
        last = [1]
        res.append(last)
        last = [0] + last
        last = last + [0]
        
        for i in range(1, numRows):
            curr = []
            for j in range(1, len(last)):
                curr.append(last[j]+last[j-1])
            res.append(curr)
            last = [0] + curr
            last = last + [0]
        return res
        
```
note：
1. 想要生成新的一行，就把上一行的周围补充0，然后从第1个元素开始相邻元素相加即可。

### Rotate Image

```
class Solution:
    def rotate(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: void Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        for i in range(n):
            for j in range(i):  #  注意这里只遍历到i
                tmp = matrix[i][j]
                print(tmp)
                matrix[i][j] = matrix[j][i] 
                matrix[j][i] = tmp
        print(matrix)
        for i in range(n):
            matrix[i] = matrix[i][::-1]
```
note：
1. 先转置，再按行逆序

### Longest Common Prefix
 

```
class Solution(object):
    def longestCommonPrefix(self, strs):
        """
        :type strs: List[str]
        :rtype: str
        """
        if len(strs) == 0:
            return ""
        
        lens = [len(string) for string in strs ]
        minLen = min(lens)
        ans = []
        
        index = -1
        for i in range(minLen):
            test = strs[0][i]
            flag = False
            for string in strs[:]:
                if test == string[i]:
                    flag = True
                else:
                    flag = False
                    break
            if flag:
                ans.append(test)
            else:
                break
        return "".join(ans)
        
```
note：
1. 思路不难，就是挨个比较即可，但是其中有一些小坑，注意多个条件判断以及何时跳出循环。

### Letter Combinations of a Phone Number

```
class Solution(object):
    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        """
        if len(digits) == 0:
            return []
        d = {"2":"abc","3":"def",'4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'}
        ans = [c for c in d[digits[0]]]
        for digit in digits[1:]:
            chars = d[digit]
            temp = []
            for item in ans:
                for char in chars:
                    temp.append(item+char)
            ans = temp  # 这一步是关键，加挂了字符的ans用于下次遍历
        return ans
```


### 双指针法

### Two Sum II - Input array is sorted


```
class Solution:
    def twoSum(self, numbers, target):
        """
        :type numbers: List[int]
        :type target: int
        :rtype: List[int]
        """
        start = 0
        end = len(numbers)-1
        
        while start < end:
            if numbers[start]+numbers[end] == target:
                return [start+1, end+1]
            elif numbers[start]+numbers[end] > target:
                end -= 1
            else:
                start += 1
                
```

### Remove Element


```
class Solution:
    def removeElement(self, nums, val):
        """
        :type nums: List[int]
        :type val: int
        :rtype: int
        """
        
        k = 0
        for i in range(len(nums)):
            if nums[i] != val:
                nums[k] = nums[i]
                k += 1
        return k
        
```
note：
1. 快慢双指针，i是快指针，用来遍历数组，k是满指针，用来追踪要替换的位置
2. 只有在满足条件的时候，k才移动


### Max Consecutive Ones


```
class Solution:
    def findMaxConsecutiveOnes(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        k = 0
        maxNum = 0
        for i in range(len(nums)):
            if nums[i] == 1:
                k += 1
                maxNum = max(k, maxNum)
            else:
                k = 0
        return maxNum
```

### Minimum Size Subarray Sum


```
class Solution:
    def minSubArrayLen(self, s, nums):
        """
        :type s: int
        :type nums: List[int]
        :rtype: int
        """
        k = 0
        minLen = len(nums)+1
        tmp = 0 
        for i in range(len(nums)):
            tmp += nums[i]
            while tmp >= s:
                minLen = min(minLen, i-k+1)
                tmp -= nums[k]
                k += 1
                
        return minLen if minLen != len(nums)+1 else 0
        
```
note：
1. 这个问题重点在内部的while循环上，当两个指针中间的sum大于等于s后，要从前向后依次抛掉前面的数，知道中间和再次小于s，才继续向后加数

### Palindrome Number

```
class Solution:
    def isPalindrome(self, x):
        """
        :type x: int
        :rtype: bool
        """
        num = str(x)
        n = len(num)
        i = 0
        j = n-1
        while i <= j:
            if num[i] == num[j]:
                i += 1
                j -= 1
            else:
                return False
        return True
```


### Sort Colors
```
class Solution(object):
    def sortColors(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        left = 0
        right = len(nums)-1
        i = 0
        while(i <= right):
            if nums[i] == 0:
                nums[left], nums[i] = nums[i], nums[left]
                left += 1
            elif nums[i] == 1:
                i += 1
            else:
                nums[right], nums[i] = nums[i], nums[right]
                right -= 1
```
one-pass的过程参考了师兄的博客，主要思路是设置三个指针，left指向第一个1的元素，right指向最后一个非2的元素，i作游标。遍历的时候，发现0就和left交换，left和i指针前移，1的时候i指针前移，2的时候和right交换，注意这里有一个坑，i要不要前移，因为现在right交换过去之后可能是0或者是1，如果是0还需要判断。

### Rotate Array


```
class Solution:
    def rotate(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        
        
        
        def reverse(nums, start, end):
            
            while start <= end:
                tmp = nums[start]
                nums[start] = nums[end]
                nums[end] = tmp
                
                start += 1
                end -= 1
        k %= len(nums)
        if len(nums) > k:
            reverse(nums, 0, len(nums)-k-1) #  注意这里的减1
            reverse(nums, len(nums)-k, len(nums)-1) 
            reverse(nums, 0, len(nums)-1)
        else:
            reverse(nums, 0, len(nums)-1)
```
note：
1. 先分段翻转，然后整体翻转
2. 注意，k可能大约nums长度，此时需要取模
3. 如果k正好是等于nums长度，就把数组从头到尾翻转，这是一个特殊case
4. 翻转代码就是首尾双指针即可。

### Set Matrix Zeroes

leetcode第73题，要求将一个矩阵内所有零元素所在的行和列全部归零。要求尽可能低的空间复杂度。

低空间复杂度其实就是看如何处理零元素所在位置的记录问题，一开始我用了一个列表记录零元素的坐标位置，这种方法显然比较笨，如果零元素很多，那么这个开辟的内存空间就会逼近矩阵的大小，加上坐标是数值对，因此可能会远远超过矩阵本身。

另一种思路是，让出第一行和第一列，用来标记零元素的位置，一旦该行出现了零元素，就把第一行和第一列的元素归零，第二遍扫的时候只有看第一行和第一列的元素就可以开始归零的操作了。

还有一个细节问题，那就是第一行和第一列如果也有零元素，需要特殊处理，需要实现设置标记位，如果出现了要到最后把第一行第一列清零。

    class Solution(object):
        def setZeroes(self, matrix):
            """
            :type matrix: List[List[int]]
            :rtype: void Do not return anything, modify matrix in-place instead.
            """
            row = len(matrix)
            column = len(matrix[0])
            
            first_row = False
            first_column = False
            
            for i in range(row):
                for j in range(column):
                    if matrix[i][j] == 0:
                        if i == 0:
                            first_row = True
                        if j == 0:
                            first_column = True
                        
                        matrix[i][0] = 0
                        matrix[0][j] = 0
            
            for i in range(1, row):
                if matrix[i][0] == 0:
                    for j in range(1, column):
                        matrix[i][j] = 0
                if first_column:
                    matrix[i][0] = 0
                    
                        
            for j in range(1, column):
                if matrix[0][j] == 0:
                    for i in range(1, row):
                        matrix[i][j] = 0
                if first_row:
                    matrix[0][j] = 0
            

### Merge Sorted Array

leetcode第88题，这道题是将两个有序数组合并，但是要求在原来的一个数组上进行原地操作。

这个题目并不难，但是测试数据不知道怎么搞，不过程序原理明白就差不多了。

典型的双指针法，两个指针分别指向两个数组最末尾的两个数，比较大小，最大的那个数就放到nums1的最末尾，然后指针前移，直到最后，看看nums2中有没有剩余的元素，把剩余的都放到前面就可以了。

    class Solution(object):
        def merge(self, nums1, m, nums2, n):
            """
            :type nums1: List[int]
            :type m: int
            :type nums2: List[int]
            :type n: int
            :rtype: void Do not return anything, modify nums1 in-place instead.
            """
            while n > 0 and m > 0:
                if nums1[m-1] >= nums2[n-1]:
                    nums1[m+n-1] = nums1[m-1]
                    m -= 1
                else:
                    nums1[m+n-1] = nums2[n-1]
                    n -= 1
            if n > 0:
                nums1[:n] = nums2[:n]




### Pascal's Triangle II


```
class Solution:
    def getRow(self, rowIndex):
        """
        :type rowIndex: int
        :rtype: List[int]
        """
        if rowIndex == 0:
            return [1]
        res = []
        for i in range(rowIndex+1):
            res.append(1)
            for j in range(i-1, 0, -1):  # i-1代表从倒数第二个开始，0到正数第二个为止
                res[j] = res[j]+res[j-1]
            
        return res
```
note：
1. 注意循环的时候是从后向前捋，从倒数第二个开始，到正数第二个结束，因为两边都是1，是不需要动的

### Reverse Words in a String


```
class Solution(object):
    def reverseWords(self, s):
        """
        :type s: str
        :rtype: str
        """
        s = s[::-1]
        words = s.split()
        newwords = []
        for word in words:
            word = word[::-1]
            newwords.append(word)
        ans = " ".join(newwords)
        return ans
```
note：
1. 把字符串整个翻转一遍，然后逐个单词再翻转。

###  Remove Duplicates from Sorted Array



```
class Solution:
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if len(nums) < 1:
            return 0
        index = 1
        for i in range(1, len(nums)):
            if nums[i] != nums[index-1]:
                nums[index] = nums[i]
                index += 1
                
        return index
```
note：
1. 注意，这个题的前提是排序数组
2. 快慢指针，i是快指针用来遍历，index是慢指针，用来追踪要替换的数字位置
3. 

### Move Zeroes

```
class Solution:
    def moveZeroes(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        index = 0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[index], nums[i] = nums[i], nums[index]
                index += 1
```
note：
1. 同样是快慢指针题
## 动态规划（DP）

### 经典：LIS


```
class Solution:
    def lengthOfLIS(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if nums == []:
            return 0
        dp = [1]*len(nums)
        for i in range(len(nums)):
            for j in range(0, i):
                if nums[j] < nums[i]:
                    dp[i] = max(dp[i], dp[j]+1)
        return max(dp)
```
note：
1. 从头到尾遍历数组，找到i位置之前的，如果i前面有比他小的，就更新dp数组，更新比较的对象是，j算上当前的i构成了dp[j]+1,一个是dp[i]本身，两者取最大值。


### LCS

```
def LCS(string1, string2):

    n1 = len(string1)
    n2 = len(string2)
    dp = [[0]*(n2+1) for i in range(n1+1)]  # 形成一个n1*n2的dp矩阵

    for i in range(n1):  # 清理掉首行首列
        dp[i][0] = 0

    for i in range(n2):
        dp[0][i] = 0

    for i in range(1, n1+1):  # 从1开始遍历
        for j in range(1, n2+1):
            if string1[i-1] == string2[j-1]:  # 递归公式
                dp[i][j] = dp[i-1][j-1]+1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])

    return dp[n1][n2]   # 返回dp矩阵的最后的元素

```
![image](https://pic002.cnblogs.com/images/2012/214741/2012111100085930.png)


### 最长公共子串

```
def LCString(string1, string2):

    n1 = len(string1)
    n2 = len(string2)
    dp = [[0] * (n2 + 1) for i in range(n1 + 1)]  # 形成一个n1*n2的dp矩阵

    for i in range(n1):  # 清理掉首行首列
        dp[i][0] = 0

    for i in range(n2):
        dp[0][i] = 0

    res = 0
    for i in range(1, n1):
        for j in range(1, n2):
            if string1[i-1] == string2[j-1]:  # 递归公式
                dp[i][j] = dp[i-1][j-1] + 1
                res = max(dp[i][j], res)  # 结果并不一定是在最后
            else:
                dp[i][j] = 0
    return res
```

![image](https://images2017.cnblogs.com/blog/1234089/201711/1234089-20171122204613133-1742322051.png)

### 编辑距离


```
class Solution:
    def minDistance(self, word1, word2):
        """
        :type word1: str
        :type word2: str
        :rtype: int
        """

        l1 = len(word1)
        l2 = len(word2)
        
        dp = [[0] * (l2+1) for i in range(l1+1)]  # 二维dp，注意范围是[0-l]，都是闭区间
        
        for i in range(l1+1):   # 初始化dp数组，从长度为0变换到长度为i（j）都需要i（j）步
            dp[i][0] = i
        for j in range(l2+1):
            dp[0][j] = j
        
        for i in range(1, l1+1):
            for j in range(1, l2+1):
                if word1[i-1] == word2[j-1]:
                    f = 0
                else:
                    f = 1
                dp[i][j] = min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+f)  # 转移方程
                
        return dp[-1][-1]
```

https://blog.csdn.net/mebiuw/article/details/51420544

1. 从i-1,j 为T1增加一个字符，获得i，j，这样编辑距离本身就需要+1 
2. 同理，从i，j-1过来，编辑距离必须+1。 
3. 从i-1，j-1位置变换过来，那么这个时后，如果T1在i的取值和T2在j的取值一样，那么这个变换，编辑距离不变，如果不一样，那么就需要做替换操作，那么必须+1.

### Maximum Subarray ##
> Find the contiguous subarray within an array (containing at least one number) which has the largest sum.
For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.

首先注意这里是最大子串和，子串是连续的，子序列不连续。
使用DP，先找状态，dp[i]代表了以i为结尾的最大子串和。
遍历数组，对于每一个数字，都有两种选择。第一种，加入到前面的子串中求和，第二种单独起一个子串。
显然，判断这两种情况哪一种更大，就应该选哪一种。
```
class Solution:
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)
        dp = [0]*n
        for i in range(n):
            dp[i] = max(dp[i-1]+nums[i], nums[i])
        
        print(dp)
        return max(dp)
```
dp数组在样例中跑出来是这个样子
[-2, 1, -2, 4, 3, 5, 6, 1, 5]
第一个不用说，肯定是nums[0]本身，也就是-2。
第二个可以选择单独作为一个子串起始，或者和前面一个，也就是dp[i-1]合并，前面的-2小于0，对求和有反作用，因此单独起一个是好的选择，代码中dp[1]就变成了nums[1]。
第三个数字是-3，它本身是-3，合并到前面去，也就是和1组成子串无疑更好。dp[2]=-3+1=-2
第四个数字是4，无疑和第二个情况是类似的。
其余情况以此类推。

上述方法时间复杂度O(n)，空间复杂度O(n)。通过分析不难发现，其实好像用不到开一个dp数组，因为我们每次关心的都是dp[i-1]，也就是前面那个dp的值。因此只需要保留一个变量tempSum作为dp[i-1]的角色。如果tempSum大于0，对后面加和有贡献，就算上当前的nums[i]，否则对后面加和有反作用，直接赋值为0，使得下一个位置的数字重新开一个子串。这样空间复杂度只有O(1)了。


```
class Solution(object):
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)
        
        tempSum = 0
        maxSum = float('-inf')
        for i in range(n):
            tempSum += nums[i]
            if tempSum > maxSum:
                maxSum = tempSum
            if tempSum < 0:
                tempSum = 0
        return maxSum
```


        



### coin change
> You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.
Example 1:
coins = [1, 2, 5], amount = 11
return 3 (11 = 5 + 5 + 1)
Example 2:
coins = [2], amount = 3
return -1.

硬币找零，要求用数量最少的硬币。背包问题。
维护dp数组，dp[i]表示目标钱数为i时最少的硬币数目。
双重循环，外层循环遍历dp数组，内层循环主要是试探有没有可以去掉一种币值，还能凑出来目标数的可能。
注意，因为是求最小值，初始化的时候初始化一个大的数，这里去目标数+1，主要是为了方便最后如果没有可行的方案，那么最后就不会更新，仍然为目标数+1，大于目标数本身，这样一来直接返回-1。
另外，初始化dp要从初始化[0，目标数]，全部是闭区间，dp[0]=0表示目标数为0时最少有0种硬币可以凑出。

```
class Solution:
    def coinChange(self, coins, amount):
        """
        :type coins: List[int]
        :type amount: int
        :rtype: int
        """
        if amount == 0:
            return 0
        dp = [amount+1]*(amount+1)
        dp[0] = 0
        for i in range(1, amount+1):
            for coin in coins:
                 if coin <= i:
                    dp[i] = min(dp[i], dp[i-coin]+1)
        print(dp)
        return -1 if dp[amount] > amount else dp[amount]
```


## leetcode 377. Combination Sum IV ##

> Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.
Example:
nums = [1, 2, 3]
target = 4
The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
Note that different sequences are counted as different combinations.
Therefore the output is 7.

和上面的题很类似，但是这次是要统计的方案数目。
dp[i]表示的是以目标数为i的时候方案总数。
需要修改的就是状态转移方程。

```
class Solution:
    def combinationSum4(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        n = len(nums)
        dp = [0]*(target+1)
        dp[0] = 1
        for i in range(1, target+1):
            for num in nums:
                if num <= i:
                    dp[i] += dp[i-num]
        print(dp)
        return dp[-1]
```

### Longest Palindromic Substring


```
class Solution:
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        
        n = len(s)
        dp = [[False] * n for i in range(n)]  # n*n的dp矩阵
        maxlen = 0
        ans = ""
        
        for i in range(0, n):  # 双层遍历
            for j in range(0, i+1):  # 从0到i本身
                
                # i-j<=2本身有三层含义，单个字符本身是回文，两个字符相等是回文，三个字符首尾相等是回文。其余的回文就要看dp数组中间夹的是不是回文
                if (i-j <= 2 or dp[j+1][i-1]) and s[i] == s[j]: 
                    dp[j][i] = True   # 先j后i，先内后外
                    if i-j+1 > maxlen:  # 获取最大的即可
                        maxlen = i-j+1
                        ans = s[j:i+1]
        
        return ans
```
### Unique Paths

```
class Solution(object):
    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        if m == 0 or n == 0:
            return 0
        d = [[0 for i in range(n)] for i in range(m)]
        d[0][0] = 1
        for i in range(1, m):
            d[i][0] = 1
        for i in range(1, n):
            d[0][i] = 1
        for i in range(1, m):
            for j in range(1, n):
                d[i][j] = d[i-1][j]+d[i][j-1]
        return d[-1][-1]
```
note：
1. dp最重要的就是两步，一步是找出状态转移方程，一步是确定初始化的状态。
2. 本题的初始化状态是第一列和第一行全部要置1，代表了起始都有一种走法。


### Unique Paths II


```
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid):
        """
        :type obstacleGrid: List[List[int]]
        :rtype: int
        """
        r = len(obstacleGrid)
        c = len(obstacleGrid[0])
        dp = [[0]*c for row in range(r)]

        if obstacleGrid[0][0] == 1:
            return 0

        for i in range(r):
            for j in range(c):
                if obstacleGrid[i][j] == 1: # 障碍物不能走，直接归零
                    dp[i][j] = 0
                elif i == 0 and j == 0:  # 相当于初始化，开始起点只有1种走法
                    dp[i][j] = 1
                elif i == 0 and j > 0:
                    dp[i][j] = dp[i][j-1]  # 边缘正能从左边或者上边继承走法
                elif i > 0 and j == 0:
                    dp[i][j] = dp[i-1][j]
                else:
                    dp[i][j] = dp[i-1][j]+dp[i][j-1]  # 中间可以从两个方向继承走法

        return dp[-1][-1]
```
note
1. 这个题加了障碍，只要在障碍处把dp数组归零就好了
2. 

### Minimum Path Sum

```
class Solution:
    def minPathSum(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        r = len(grid)
        c = len(grid[0])

        dp = [[0]*c for row in range(r)]
        dp[0][0] = grid[0][0]

        for i in range(r):
            for j in range(c):
                if i == 0 and j > 0:
                    dp[i][j] = dp[i][j-1] + grid[i][j]
                elif i > 0 and j == 0:
                    dp[i][j] = dp[i-1][j] + grid[i][j]
                elif i > 0 and j > 0:
                    dp[i][j] = min(dp[i - 1][j] + grid[i][j], dp[i][j-1] + grid[i][j])

        return dp[-1][-1]
```
note
1. 这里的数组是非负的，保证了第一行第一列更新时直接加是可行的
2. 其余的思路基本和上题一致。
3. 


### Unique Binary Search Trees


```
class Solution:
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        
        if n == 0 or n == 1:
            return 1
        
        dp = [0] * (n+1)  # [0-n], 0表示没有节点
        dp[0] = 1
        
        for i in range(1, n+1):  # 从1到n遍历，依次以i作为root node
            for j in range(0, i):   # 从1到i-1遍历
                dp[i] += dp[j]*dp[i-j-1]  # 地推公式，其中i-j-1中的1代表已经选取i作为root
        
        return dp[n]
    
```
http://www.cnblogs.com/springfor/p/3884009.html
https://blog.csdn.net/yinchaoji_/article/details/70137002

### Perfect Squares
https://leetcode.com/problems/perfect-squares/description/
```

class Solution:
    def numSquares(self, n):
        """
        :type n: int
        :rtype: int
        """
        dp = [i for i in range(n+1)]

        for i in range(1, n+1):
            j = 1
            while j*j <= i:
                dp[i] = min(dp[i-j*j]+1, dp[i])
                j += 1
        return dp[-1]
```

### Maximum Product Subarray

```
class Solution:
    def maxProduct(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)
        tmpMax = nums[0]
        tmpMin = nums[0]
        ans = nums[0]
        
        for i in range(1, n):
            
            tmp1 = tmpMax*nums[i]
            tmp2 = tmpMin*nums[i]
            
            tmpMax = max(tmp1, tmp2, nums[i])
            tmpMin = min(tmp1, tmp2, nums[i])
            ans = max(ans, tmpMax)
            
                
        return ans
            
            
        
```
### Decode Ways
https://leetcode.com/problems/decode-ways/description/
```
class Solution:
    def numDecodings(self, s):
        """
        :type s: str
        :rtype: int
        """
        
        n = len(s)
        dp = [0] * (n+1)
        
        dp[0] = 1 # 这里不知为什么初始化为1，应该是为了照顾下面的dp[i] = dp[i-1]
        
        for i in range(1, n+1):
            
            dp[i] = 0 if s[i-1] == "0" else dp[i-1]  # 前一位是0，无法编码，直接归零，如果不是就加上前一个的编码数目
            
            if i > 1 and (s[i-2] == "1" or (s[i-2] == '2' and s[i-1] <= "6")):  # 再加上合法的前两位编码数目
                dp[i] += dp[i-2]
        
        return dp[-1]
        
```
### Word Break

```
class Solution:
    def wordBreak(self, s, wordDict):
        """
        :type s: str
        :type wordDict: List[str]
        :rtype: bool
        """
        
        n = len(s)
        
        if n == 0 or len(wordDict) == 0:
            return False
        
        dp = [False] * n
        
        for i in range(n):
            if s[:i+1] in wordDict:
                dp[i] = True
                continue
            for j in range(0, i):
                if s[j+1:i+1] in wordDict and dp[j]:
                    dp[i] = True
        
        return dp[-1]
        
        
```

### Maximal Square


```
class Solution:
    def maximalSquare(self, matrix):
        """
        :type matrix: List[List[str]]
        :rtype: int
        """
        
        row = len(matrix)
        if row == 0:
            return 0
        
        col = len(matrix[0])
        
        if col == 0:
            return 0
        
        dp = [[0] * col for i in range(row)]
        
        maxNum = 0
        
        for i in range(row):
            for j in range(col):
                
                if i == 0 or j == 0:
                    if matrix[i][j] == "1":  # 边界初始化，有1的都认为是1的正方形即可
                        dp[i][j] = 1
                else:
                    if matrix[i][j] == "1":
                        dp[i][j] = min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1]) + 1  # 向上方，左方和左上方搜索，自身是1就在这三个交集上+1
                        # 正方形体现在这个交集和+1上
                maxNum  = max(dp[i][j], maxNum)
                
        return maxNum * maxNum 
        
```


## DFS 和 BFS


### Permutations

法一

全排列这个问题很明显是回溯，但是怎么找状态空间是个问题。假设1234是初始的四个数字，如何产生全排列呢？可以把第一个数字1依次与之后的数字交换，会产生一组数字分别为1234、2134、3214、4321。注意，假设1与2交换，变为2134，这又是一个新的数字，可以在此基础上再次进行上述操作，不过这回是从第二个数字开始依次与后面的数字交换，因为再从第一个开始就会又出现1234了，这样2134又会出现2134、2314、2341.如此下去，每个数字都可以这样进行操作。递归的出口就是当进行到最后一个数字时，由于没有后面数字可以交换了，前面的数字交换情况也都有了，于是可以返回。

```
class Solution:
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        import copy
        def dfs(nums, curr, ans):
            if curr == len(nums) - 1:
                ans.append(copy.deepcopy(nums))
                return
            
            for i in range(curr, len(nums)):
                nums[i], nums[curr] = nums[curr], nums[i]
                dfs(nums, curr+1, ans)
                nums[i], nums[curr] = nums[curr], nums[i]
        
        ans = []
        dfs(nums, 0 ,ans)
        return ans
```

法二


```
class Solution(object):
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        ans = []
        def dfs(nums,path,ans):
            if not nums:
                ans.append(path)
            else:
                for i in range(len(nums)):
                    dfs(nums[:i]+nums[i+1:],path+[nums[i]],ans)
        dfs(nums,[],ans)
        return ans
```
note：
1. 这里并没有显式的回溯过程，原因是，递归传入的就是去掉i项后的nums，并不影响下一轮循环中的nums，所以不必显式写出回溯过程

### Permutations II

leetcode第47题，全排列的升级版，要求需要全排列的数组中有重复，输出去重后的结果。

这个题可以充分运用语言上的特点，比如先生成带有重复项的全排列，这在之前那道题目已经完成了，然后set一下去重，但是这样做太不自然了，复杂度肯定也会依赖于set去重操作，有没有自然去掉重复项的办法呢？

可以这样考虑，为什么会产生重复项，因为数组中含有重复数字。在每一轮深搜的时候，单独设置一个dict记录用到的数字，如果在碰到相同的数字出现，就会在字典里查出来，这就意味着这个数字不用再进行下一步dfs了，因为已经有一个和它完全相同的数字已经搜索了，这样就自然去重了。

```
class Solution(object):
    def permuteUnique(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """

        ans = []
        def dfs(nums, ans, path):
            if not nums:
                ans.append(path)
            else:
                d = {}  # 每一步递归都要建一个dict用来去重
                for i in xrange(len(nums)):
                    if nums[i] not in d:
                        dfs(nums[:i]+nums[i+1:], ans, path+[nums[i]])
                        d[nums[i]] = 1
        nums.sort()
        dfs(nums, ans, [])
        return ans
```

### Next Permutation

leetcode第31题，要求给定一组数字，输出字典序下下一个全排列，要求原地修改。

首先，要求原地修改，就不要想着先生成在去查找这个办法了。其实这个方法比较难想出来，主要是找按字典序排列的相邻的全排列之间有什么规律。

从最后一位向前搜索，如果一直处于递增状态，说明这一段全排列没法动，因为这一个子段已经处于字典序的最大值了，无论怎么换，都不可能增大这一段的字典序。直到发现搜索到某个位置，递增被打断，说明这个地方还没有满足全排列的最大值，可以做手脚了。于是我们从这个截断点反向搜索一个只比他小一点的数，交换其位置。最后一步，由于这个子段已经处于全排的最大字典序，因此就如同加法进位一样，自动回转到字典序最小值，也就是逆序一下就可以了。

```
class Solution(object):
    def nextPermutation(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        def swap(nums,i1,i2):
            tmp = nums[i1]
            nums[i1] = nums[i2]
            nums[i2] = tmp

        def reverse(nums, start, end):
            while start < end:
                swap(nums, start, end)
                start += 1
                end -= 1

        n = len(nums)
        i = n-2
        while i >= 0 and nums[i+1] <= nums[i]:
            i -= 1
        if i >= 0:
            j = n-1
            while j >= 0 and nums[j] <= nums[i]:
                j -= 1
            swap(nums, i, j)
        reverse(nums, i+1, n-1) # 从i后一格到最后翻转
```


### Permutation Sequence

比较好的方法是使用康托展开，关于这一部分我参见了这个blog http://blog.csdn.net/synapse7/article/details/16901489

    def getPermutation3(n, k):
        import math
        factor = [math.factorial(i) for i in range(0, n + 1)]
        print factor
        visit = [False] * (n+1)

        ans = ""
        k -= 1
    
        for i in range(1, n+1): #从1到n遍历
            tmp = k/factor[n-i]
            for j in range(1, n+1): # 从1到n检查有没有用过的数字
                if visit[j] == False:
                    if tmp == 0:
                        break
                    tmp -= 1
            visit[j] = True
            ans += str(j)
            k %= factor[n-i]
        return ans


### Combination Sum

leetcode第39题，回溯题，要求用给定集合中的数字使得相加等于目标数字，其中给定集合中的数字可以无限次使用。

注意，这里题目要求所有数字都是正数，这就保证了递归的出口条件。

分析问题，首先，递归的出口条件有两个，一个是相加出现了目标和，那么就加入了结果列表，返回。另外，由于给定集合都是正数，所以相加如果超过了目标和，就要立即返回。然后遍历集合，不断向下递归搜索。

还有一个比较关键的问题，就是如何去重。这里我们先把目标集合排一下序，然后在递归搜索的时候先判断要加入的数字和之前列表中最后一个数字的大小关系，这样就确保了我们搜索出来的结果一定是一个递增的关系，这样就会不会重复了。

    class Solution(object):
        def combinationSum(self, candidates, target):
            """
            :type candidates: List[int]
            :type target: int
            :rtype: List[List[int]]
            """
            n = len(candidates)
            candidates.sort()
            ans = []
            def dfs(tryList):
                if sum(tryList) == target:
                    ans.append(tryList)
                    return
                if sum(tryList) > target:
                    return
                for i in range(n):
                    if len(tryList) != 0 and  candidates[i] < tryList[-1]:
                        continue
                    dfs(tryList+[candidates[i]])
            dfs([])
            return ans


### Combination Sum II

leetcode第40题，要求在候选数组中选出一组数字求和等于目标数，与前一题不同的是，这次每个数字只能选择一次。

首先要明白每个数字只能选一次，一开始想用一个数组记录一下每个数是否被用过，但是很快发现这个数组如果是全局的完全没有效果，于是就引入了深拷贝，确保每个递归函数拿到的都是其副本而不是视图，但是这样做大数据跑不过去。

其实按照dfs的思路，去重并不是很麻烦的一件事，完全不需要申请额外内存，因为只要记录一下每次从什么位置开始深搜，这样就不会重复，不过这里有一个小陷阱，那就是候选数组中会有重复的数字，这样也会造成重复。解决办法是，dfs之前先对数组排序，dfs的时候判断一下前后两个数字是不是一样的，如果一样就跳过，避免重复结果出现。

```
class Solution(object):
    def combinationSum2(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        import copy
        ans = []
        candidates.sort()

        def dfs(tryList, start):
            if sum(tryList) == target:
                ans.append(tryList)
                return
            elif sum(tryList) > target:
                return

            for i in range(start, len(candidates)):
                if i != start and candidates[i] == candidates[i - 1]:
                    continue
                dfs(tryList+[candidates[i]], i+1)

        dfs([], 0)
        return ans
```

### Combinations

leetcode第77题，排列组合题升级版，这个题的总体难度不太大，但是鉴于使用的是python，如果不剪枝，就一定会超时。

首先分析问题，先要按顺序挑选出开头的元素，此时所给集合中的所有元素均可以添加，然后把加上了开头元素的列表向下递归，添加第二个元素，第二个元素的要求应该是第一个元素之后的所有元素均可，同时记录递归层级的变量level自增。递归的出口条件是，当level达到了指定的个数后，数名数字添加完毕，则可以加入最终的结果列表中。

如果单纯这样写结果正确，但是大数据会TLE，于是参考别人的剪枝方法，那就是在递归添加元素的过程中，如果发现所剩的元素根本不够，即使全部用掉也凑不够k个，这样的循环就可以提前终止了。这个剪枝卡了我很久，不加这个就会超时。

    class Solution(object):
        def combine(self, n, k):
            """
            :type n: int
            :type k: int
            :rtype: List[List[int]]
            """
            ans = []
            def dfs(subList,start,level):
                if level == k:
                    ans.append(subList)
                    return
                for i in xrange(start,n+1):
                    if n-i < k-level-1 :break
                    dfs(subList+[i],i+1,level+1)
            dfs([],1,0)
            return ans


### Subsets

leetcode第78题，寻找给定集合的所有子集，包括空集。

一开始准备使用深搜，这也做倒也没啥问题，但是去重是一个很麻烦的事情。换种思路决定用二进制来做。

将给定集合的每个元素分别用一个二进制位代表，1表示该元素在子集合中，0表示不在子集中。这样所有二进制数的情况就对应了所有子集的可能情况，只要一一对应出来即可。

注意python的bin函数是转换二进制数，但是前面带着一个0b字符，所以我们要对它做一些处理，还要对齐数位，形成一个标准的字符串。

    class Solution(object):
        def subsets(self, nums):
            """
            :type nums: List[int]
            :rtype: List[List[int]]
            """
            n = len(nums)
            binNum = 2**n
            ans = []
            for i in range(binNum):
                s = "0"*(n-len(str(bin(i))[2:]))+str(bin(i))[2:]
                print s
                subAns = []
                for j in range(n):
                    if s[j] == '1':
                        subAns.append(nums[j])
                ans.append(subAns)
            return ans
最近又学习了另外一种思路，回溯法，主要是用到了dfs，基本思路是，数组排序之后，每次按顺序向path中加入一个数字，加入后用dfs扩展后一位，每次进入递归函数时都要保存到最终结果数组中，当扩展到最后一位时，函数返回到上一层，上一层函数把最后一位删去，再引进下一位。

    class Solution:
        def subsets(self, nums):
            """
            :type nums: List[int]
            :rtype: List[List[int]]
            """
            n = len(nums)
            nums.sort()
            def dfs(nums,pos, path, ans):
                import copy
                ans.append(copy.deepcopy(path))
                for i in range(pos,len(nums)):
                    path.append(nums[i])
                    dfs(nums, i+1, path, ans)
                    path.pop()
            ans = []
            dfs(nums, 0, [], ans)
            return ans

### Subsets II

```
class Solution:
    def subsetsWithDup(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        
        self.ans = []
        
        def dfs(nums, pos, path):
            
            self.ans.append(copy.deepcopy(path))
            
            d = {}
            for i in range(pos, len(nums)):
                
                if nums[i] not in d:
                
                    dfs(nums, i+1, path+[nums[i]])
                    
                    d[nums[i]] = 1
        
        nums.sort()
        dfs(nums, 0, [])
        return self.ans  
```
note：
1. 使用字典记录重复的值，达到去重的目的
2. 先要对序列排序是很关键的一步，只有这样才可以保证从i向后搜索不会搜到相同的数字

### word search

leetcode 第79题，图上的深搜题。
第一步，先要写个遍历循环，找到搜索的起点，也就是首字母。
第二步，从起点出发开始搜索，搜索时主要要记录已经走过的地方，这里可以使用一个二维的数组单独来记录，或者走过的地方标识为‘#’，搜索后恢复这个位置的字符。
注意，每次搜索时，都要比较word和当前路径已经遍历到的字符，这里可以使用增量式的比较方法，每次比较一个字符即可。

```
class Solution:
    def exist(self, board, word):
        """
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """
        row = len(board)
        col = len(board[0])
        
        def dfs(current_x, current_y, board, index, word):
            
            if index == len(word)-1:
                return True
            tmp = board[current_x][current_y]
            board[current_x][current_y] = '#'
            if current_x+1 < row and board[current_x+1][current_y] == word[index+1]:
                if dfs(current_x+1, current_y, board, index+1, word):
                    return True
            if current_x-1 >= 0 and board[current_x-1][current_y] == word[index+1]:
                if dfs(current_x-1, current_y, board, index+1, word):
                    return True
            if current_y+1 < col and board[current_x][current_y+1] == word[index+1]:
                if dfs(current_x, current_y+1, board, index+1, word):
                    return True 
            if current_y-1 >= 0 and board[current_x][current_y-1] == word[index+1]:
                if dfs(current_x, current_y-1, board, index+1, word):
                    return True
            board[current_x][current_y] = tmp
            
            return False
                
        for i in range(row):
            for j in range(col):
                if board[i][j] == word[0]:
                    if dfs(i, j, board, 0, word):
                        return True
        return False
                    
```

### Restore IP Addresses

leetcode第93题，计算有效的IP地址。

分析问题，首先什么是有效的IP，这里有效是广义的，也就是凡是符合IP的要求的都算，不考虑特殊IP地址的限制。这样有效IP的要求就放宽了不少，首先IP应该有四级，每一个的数字都应该在0-255之间，还有一点比较隐蔽，那就是0单独出现时正确的，但是如“”010”这样的数字就是不合法的了。

确认有效IP的格式后，就要分析算法，这里运用深度搜索，递归出口条件有两个，一个是长度上不符合要求则要立刻返回，而是当递归到最后一层时需要判断首位是否为0且在0-255范围内。

递归的时候，遍历方式为从当前第一个字符开始依次向后扩展1-3个字符。

    class Solution(object):
        def restoreIpAddresses(self, s):
            """
            :type s: str
            :rtype: List[str]
            """
            def dfs(string,n):
                if len(string) > 3*n or len(string) < n: # 如果长度不符合要求则直接返回
                    return []
                if n == 1: # 考虑处理到最后的字符串的情况
                    if string[0] == '0' and len(string) > 1: # 开头是0，但不是单个的0返回
                        return []
                    if int(string) > 255: # 最后的子串超出范围返回
                        return []
                    return [string]
        
                ret = []
                for i in xrange(1,4):
                    if string[0] == '0' and i > 1: # 开头是0，不是单个的0
                        continue
                    if int(string[:i]) > 255: # 超出返回
                        continue
                    iret = dfs(string[i:],n-1) # 深搜
                    if len(iret) > 0:
                        ret += [string[:i]+'.'+iiret for iiret in iret]
                return ret
        
            return dfs(s,4)

### Unique Binary Search Trees II

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def generateTrees(self, n):
        if n == 0:
            return []
        return self.helper(1, n)

    def helper(self, start, end):
        result = []
        if start > end:  # 出口条件是 start比end大了，此时子树为空，但还要以list形式返回
            result.append(None)
            return result

        for i in range(start, end + 1):  # 从start到end，依次以i为root node
            # generate left and right sub tree
            leftTree = self.helper(start, i - 1)    # 返回的是左右子树list
            rightTree = self.helper(i + 1, end)
            # link left and right sub tree to root(i)
            for j in range(len(leftTree)):    # 分别加挂左右子树
                for k in range(len(rightTree)):
                    root = TreeNode(i)
                    root.left = leftTree[j]
                    root.right = rightTree[k]
                    result.append(root)

        return result
                
```

### Triangle

```
class Solution(object):
    def minimumTotal(self, triangle):
        """
        :type triangle: List[List[int]]
        :rtype: int
        """
        n = len(triangle)
        for i in range(n-2, -1, -1):
            l = len(triangle[i])
            print l
            for j in range(l):
                triangle[i][j] = min(triangle[i+1][j+1]+triangle[i][j], triangle[i+1][j]+triangle[i][j])

        return triangle[0][0]
```
### Best Time to Buy and Sell Stock

leetcode第121题，简单题，要求寻找一个最好的买入卖出时机，使得两个数字相差最大，即获益最多。
题目提示是动态规划，但实际好像没那么复杂。首先，一种最直接的思路，两边循环搞定，外循环遍历买入时机，内循环遍历卖出时机。
能不能简化一下呢，假设只用一次循环，就是遍历卖出时机，什么时候卖出呢，当然是与之前的所有值中最小值差距最大的时候，这就很明显了，我们可以一边遍历卖出点，一遍记录卖出点之前的最小值，这样就可以求出最大收益了。

```
public class Solution {
    public int maxProfit(int[] prices) {
		if (prices == null || prices.length == 0){
			return 0;
		}
		int min = prices[0];
		int len = prices.length;
		int profit = 0;
		for(int i = 0;i < len;i++){
			min = Math.min(min, prices[i]);
			profit = Math.max(prices[i]-min, profit);
		}
	    return profit;
    }
}
```
### House Robber

```
class Solution(object):
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)
        if len(nums) == 0: # 下面方法要求list必须有两个元素，两个及两个以下的元素可以单独处理
            return 0
        if len(nums) == 1:
            return nums[0]
        if len(nums) == 2:
            return max(nums)
            
        dp = [0]*n
        dp[0] = nums[0]
        dp[1] = max(nums[1], nums[0])
        for i in range(2, n):
            dp[i] = max(dp[i-2]+nums[i], dp[i], dp[i-1])
        return max(dp)
```

### House Robber II

```
class Solution:
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        def robv1(nums):
            
            n = len(nums)
            if len(nums) == 0: # 下面方法要求list必须有两个元素，两个及两个以下的元素可以单独处理
                return 0
            if len(nums) == 1:
                return nums[0]
            if len(nums) == 2:
                return max(nums)

            dp = [0]*n
            dp[0] = nums[0]
            dp[1] = max(nums[1], nums[0])
            for i in range(2, n):
                dp[i] = max(dp[i-2]+nums[i], dp[i], dp[i-1])
            return max(dp)
        
        n = len(nums)
        if len(nums) == 0: # 下面方法要求list必须有两个元素，两个及两个以下的元素可以单独处理
            return 0
        if len(nums) == 1:
            return nums[0]
        if len(nums) == 2:
            return max(nums)
        
        ans = max(robv1(nums[:-1]),robv1(nums[1:]))
        return ans
```
这道题是之前那道House Robber 打家劫舍的拓展，现在房子排成了一个圆圈，则如果抢了第一家，就不能抢最后一家，因为首尾相连了，所以第一家和最后一家只能抢其中的一家，或者都不抢，那我们这里变通一下，如果我们把第一家和最后一家分别去掉，各算一遍能抢的最大值，然后比较两个值取其中较大的一个即为所求。那我们只需参考之前的House Robber 打家劫舍中的解题方法，然后调用两边取较大值，
### Path Sum II


https://leetcode.com/problems/path-sum-ii/description/
```
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def pathSum(self, root, sumNum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: List[List[int]]
        """
        import copy
        
        def dfs(node, tmpSum, path, ans):

            if node == None:
                return 
            
            if node.left == None and node.right == None and tmpSum == 0:
                ans.append(copy.deepcopy(path))
            
            if node.left:
                path.append(node.left.val)
                dfs(node.left, tmpSum-node.left.val, path, ans)
                path.pop()
            
            if node.right:
                path.append(node.right.val)
                dfs(node.right, tmpSum-node.right.val, path, ans)
                path.pop()
                
          
            
        if root == None:
            return []
        ans = []
        dfs(root, sumNum-root.val, [root.val], ans)
        return ans
```


## greedy 贪心法

### Jump Game

```
class Solution(object):
    def canJump(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """

        maxState = nums[0]
        for i in range(1, len(nums)):
            if maxState >= i:
                maxState = max(nums[i]+i, maxState)
        return True if maxState >= len(nums)-1 else False
```
note：
1. 每一步探索最远能到的位置即可
2. 注意，这里数组元素代表的最远可以往前跳多远，而不是只能跳到这么远
3. 

### Merge Intervals

```
# Definition for an interval.
# class Interval(object):
#     def __init__(self, s=0, e=0):
#         self.start = s
#         self.end = e

class Solution(object):
    def merge(self, intervals):
        """
        :type intervals: List[Interval]
        :rtype: List[Interval]
        """
        
        if len(intervals) == 0:
            return []
        
        intervals.sort(key=lambda x:x.start)
        print [(item.start, item.end) for item in intervals]
        
        ans = [intervals[0]]
        
        for i in range(1, len(intervals)):
            if ans[-1].end < intervals[i].start:
                ans.append(intervals[i])
            else:
                ans[-1].end = max(ans[-1].end, intervals[i].end)
           
        return ans
                
```
note：
1. 先按照开始时间排序，然后逐个合并，如果出现重叠，就更新末尾的结束时间点。
2. 

## 二分搜索


### Sqrt(x)


```
class Solution(object):
    def mySqrt(self, x):
        """
        :type x: int
        :rtype: int
        """
        left = 0
        right = x
        mid = (left+right)/2
        while(left <= right):
            if mid * mid  == x:
                return mid
            elif mid * mid > x:
                right = mid-1
            else:
                left = mid+1
            mid = (left+right)/2
        return left-1
```


## 数学、二进制技巧

### Climbing Stairs

迭代法
```
class Solution(object):
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        n += 2
        before = 1
        beforer = 1
        for i in range(2,n):
            tmp = beforer
            beforer = before
            before = tmp+beforer
        return beforer
            
```

递归法

```
def climbStairs(n):
    if n == 0:
        return 1
    if n == 1:
        return 1
    elif n == 2:
        return 2
    elif n > 2:
        return climbStairs(n-1)+climbStairs(n-2)
```
### Number of 1 Bits

```
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int count = 0;
        while(n)
        {
            count++;
            n = n&(n-1);
        }
        return count;
    }
};
```
note:
把一个数减去1和本身与运算，结果相当于把这个数最右边的1变成了0

1. 判断是否是2的整数次方，把其中唯一的1变成0即可
2. 两个整数m和n，改变m中的二进制多少位可以变成n，先异或，在统计1的个数

### Simplify Path

leetcode第71题，要求化简linux风格的路径。

这里首先要明确linux路径的表示形式，一般而言，“.”代表当前目录，所以不用做处理，“..”代表返回上一次目录，因此就需要跳到前面那一层目录下。

很明显，这个题用栈来做会很简单，先用“/”分割字符串，然后凡是遇到“.”的情况，一律越过，不作处理，遇到字符则加入栈，遇到“..”则弹出栈，最后连接一下就可以了。

```
class Solution(object):
    def simplifyPath(self, path):
        """
        :type path: str
        :rtype: str
        """

        paths = [p for p in path.split("/") if p != "." and p != ""]
        print paths
        stack = []
        for p in paths:
            if p == "..":
                if len(stack) != 0:
                    stack.pop()
            else:
                stack.append(p)
        return "/"+"/".join(stack)
```


## 二分查找

### Search in Rotated Sorted Array



```
class Solution:
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        left = 0
        right = len(nums)-1
        
        while(left <= right):
            
            mid = (left+right)//2
            
            if nums[mid] == target:
                return mid
            
            if nums[right] <= nums[mid]:
                if nums[mid] >= target and nums[left] <= target:
                    right = mid-1
                else:
                    left = mid+1
            if nums[right] >= nums[mid]:
                if nums[mid] <= target and nums[right] >= target:
                    left = mid+1
                else:
                    right = mid-1
        return -1
```
note：
1. 先要通过mid和right的关系确定哪一部分是有序的
2. 在有序的基础上进行二分查找
3. （1）如果target==A[m]，那么m就是我们要的结果，直接返回；
（2）如果A[m]<A[r]，那么说明从m到r一定是有序的（没有受到rotate的影响），那么我们只需要判断target是不是在m到r之间，如果是则把左边缘移到m+1，否则就target在另一半，即把右边缘移到m-1。
（3）如果A[m]>=A[r]，那么说明从l到m一定是有序的，同样只需要判断target是否在这个范围内，相应的移动边缘即可。

###  Find Minimum in Rotated Sorted Array


```
class Solution:
    def findMin(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        left = 0
        right = len(nums)-1
        
        while left <= right:
            
            mid = (left+right)//2
            
            if nums[mid] > nums[len(nums)-1]:
                left = mid+1
            else:
                right = mid-1
        
        return nums[left]
        
        
```
