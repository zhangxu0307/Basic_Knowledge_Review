# 算法题集锦

## 快速排序及相关

### 快速排序


```

def partition(nums, start, end): # 注意，这个函数的start和end表示要partition的段，所以所有操作都在要在statr和end上做

    if len(nums) <= 0 or start < 0 or end >= len(nums):  # 检查下表是否合法
        return -1

    base = nums[end]  # 直接选取末尾数字作为基准点

    small = start-1  # small初始化为前一格

    for i in range(start, end): # start~end-1，end已经是基准点了
        if nums[i] < base:
            small += 1  # 先移动，在交换
            if small != i:
                nums[i], nums[small] = nums[small], nums[i]

    small += 1  # small指向第一个比base大的数字
    nums[end], nums[small] = nums[small], nums[end]
    return small


def quickSort(nums, start, end):

    if start == end:  # 递归出口条件是，start和end重合了
        return

    index = partition(nums, start, end)  # 先做partition，再递归quicksort

    if index > start:
        quickSort(nums, start, index-1)
    if index < end:
        quickSort(nums, index+1, end)
```

### 寻找第k小的元素和前k小的元素


```
def findKthSmall(nums, k):

    k -= 1  # 第k大的数，实际上在数组中是k-1那个位置的数
    start = 0
    end = len(nums) - 1
    index = partition(nums, start, end)
    while index != k:  # 注意这里是循环，知道找到index是k为止
        if index < k:
            index = partition(nums, index + 1, end) # 这里并没有递归，都是在这个函数调用partition
        if index > k:
            index = partition(nums, start, index-1)
    return nums[index]


def findKSmall(nums, k):

    k -= 1
    start = 0
    end = len(nums) - 1
    index = partition(nums, start, end)
    while index != k:
        if index < k:
            index = partition(nums, index + 1, end)
        if index > k:
            index = partition(nums, start, index - 1)
    ans = []
    for i in range(start, index+1):
        ans.append(nums[i])
    return ans
```
注意：如果是找前k大或者第k大的元素时，只需要变动partition中if nums[i] < base小于号即可。


## 二叉树及其相关

### 树的遍历

递归形式


```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


# 先序
class Solution:
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        ans = []
        def preorder(node):
            if node == None:
                return
            ans.append(node.val)
            preorder(node.left)
            preorder(node.right)
        
        ans = []
        preorder(root)
        
        return ans
        
# 中序
class Solution:
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        
        def inOrder(node,ans):
            if node == None:
                return
            inOrder(node.left, ans)
            ans.append(node.val)
            inOrder(node.right, ans)
        ans = []
        inOrder(root, ans)
        return ans
# 后序    
class Solution:
    def postorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        def postorder(node, ans):
            if node == None:
                return
            postorder(node.left, ans)
            postorder(node.right, ans)
            ans.append(node.val)
            
        ans = []
        postorder(root, ans)
        return ans
```

note:
1. 先序中序后序的区别在于什么时候访问根节点
2. 递归理解，以先序遍历为例，先访问根绝点，加入结果list，然后把整个左子树扔进函数里递归调用，递归出口是访问到叶子节点没有左右孩子时，逐层返回。
3. ans随着函数递归调用也可以，设置成全局变量也可以
4. 注意递归的出口条件，空节点时返回


### 逐层遍历树

广度搜索


```
class Solution:
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if root == None:
            return []
        ans = []
        layer = [root]
        while len(layer) != 0:
            value_layer = []
            next_layer = []
            for node in layer:
                value_layer.append(node.val)
                if node.left != None:
                    next_layer.append(node.left)
                if node.right != None:
                    next_layer.append(node.right)
            ans.append(value_layer)
            layer = next_layer
        return ans
            
```

note：
1. 维护一个layer层，每次都要在这个list中去node遍历
2. layer层每次内部循环结束后，都要更新成下一层
3. 如果node是叶子节点，下一层就没有东西加入next_layer，外层大循环的结束条件是，某一层没有任何node了。


### Path Sum 

https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/537/

bottom up解法
```
class Solution:
    def hasPathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        """
        
        def dfsBottomUp(node, sumNum, sum):
            
            sumNum += node.val
            
            if node.left == None and node.right == None:
                return True if sumNum == sum else False
            
            ans1 = ans2 = False
            if node.left != None:
                ans1 = dfsBottomUp(node.left, sumNum, sum)
            if node.right != None:
                ans2 = dfsBottomUp(node.right, sumNum, sum)
            return ans1 or ans2
        
        if root == None:
            return False
        ans = dfsBottomUp(root, 0, sum)
        return ans
                
```

note：
1. 遍历到叶子节点时，开始比较和，并把结果逐层上交。
2. 每一个节点都会收到来自于左右子树两个不同的结果，只有其中有一个是true就可以，所以使用or操作
3. 这里不需要使用回溯法，因为每个节点在调用函数的一开始加上本节点的value，各个节点之间互不影响。
4. bottom up解法的关键在于结果是在最上层给出的，因此要处理好本层和下层返还给的结果的关系，处理之后继续向上层递交结果。


top down解法

```
class Solution:
    
    def __init__(self):
        self.ans = False
    
    def hasPathSum(self, root, sum):
        """
        :type root: TreeNode
        :type sum: int
        :rtype: bool
        """
        
        def dfsTopDown(node, sumNum, sum):
            
            sumNum += node.val
            
            if node.left == None and node.right == None:
                if sumNum == sum:
                    self.ans = True
                return
            
            if node.left != None:
                dfsTopDown(node.left, sumNum, sum)
            if node.right != None:
                dfsTopDown(node.right, sumNum, sum)
        
        if root == None:
            return False
        dfsTopDown(root, 0, sum)
        return self.ans
```

note：
1. top down的精髓在于要设置一个全局的结果变量，当从上向下算到最后的时候更新这个结果变量。注意，这个结果变量必须是全局的，不能跟随一起递归。


- 最大深度


top down解法
```
class Solution:
    
    def __init__(self):
        self.maxDep = 0
    
    
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def maxDepthCore(node, depth):

            if node == None:
                return 
            if node.left == None and node.right == None:
                self.maxDep = max(depth, self.maxDep)
            maxDepthCore(node.left, depth+1)
            maxDepthCore(node.right, depth+1)
             
        ans = maxDepthCore(root, 1)
        return self.maxDep
        
```


bottom up解法


```
class Solution(object):
    def maxDepth(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        d = 0
        def dfs(root,d):
            if root == None:
                return d
            d1 = dfs(root.right,d+1)
            d2 = dfs(root.left,d+1)
            return max(d1,d2)
        d = dfs(root,d)
        return d
```

这两个方法几乎和上一个题完全一样。


### 对称树

https://leetcode.com/explore/learn/card/data-structure-tree/17/solve-problems-recursively/536/

```
class Solution:
    def isSymmetric(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        def dfs(node1, node2):
            
            if node1 == None and node2 == None:
                return True
            
            elif node1 == None or node2 == None:
                return False
            
            if node1.val != node2.val: # 注意这里不需要判断相等情况，即使相等，也并不能说明是镜像的，一定要判断到叶子节点为止
                return False
            
            ans1 = dfs(node1.left, node2.right)
            ans2 = dfs(node1.right, node2.left)
            
            return ans1 and ans2
        
        if root == None:
            return True
        ans = dfs(root.left, root.right)
        return ans
```

bottom up的方法，ans就是不断向上递交的结果。


### 由遍历结果构造树

已知后序和中序构造二叉树


```
class Solution:
    def buildTree(self, inorder, postorder):
        """
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        """
        
        if len(postorder) == 0:
            return None
        
        rootNode = postorder[-1]
        
        splitIndex = 0
        for i in range(len(inorder)):
            if inorder[i] == rootNode:
                splitIndex = i

        left_inorder = inorder[:splitIndex]
        right_inorder = inorder[splitIndex+1:]
        left_postorder = postorder[:splitIndex]
        right_postorder = postorder[splitIndex:-1]
        
        left_root = self.buildTree(left_inorder, left_postorder)
        right_root = self.buildTree(right_inorder, right_postorder)
        
        root = TreeNode(rootNode)
        root.left = left_root
        root.right = right_root
        
        return root
```

已知前序和中序构造树


```
class Solution:
    def buildTree(self, preorder, inorder):
        """
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        """
        if len(preorder) == 0 or len(inorder) == 0:
            return None
        
        rootNode = preorder[0]
        
        splitIndex = 0
        for i in range(len(inorder)):
            if inorder[i] == rootNode:
                splitIndex = i
        
        left_inorder = inorder[:splitIndex]
        right_inorder = inorder[splitIndex+1:]
        left_preorder = preorder[1:1+splitIndex]
        right_preorder = preorder[splitIndex+1:]
        
        
        left_root = self.buildTree(left_preorder, left_inorder)
        right_root = self.buildTree(right_preorder, right_inorder)
        
        root = TreeNode(rootNode)
        root.left = left_root
        root.right = right_root
        
        return root
```

note:
1. 这两种都必须有中序遍历，否则结果不是确定的
2. 两种思路极为接近，都是在本层找出root，然后把原来的遍历按照root划开，分别递归调用函数
3. 递归出口在遍历数组没有元素了为止
4. 属于bottom up方案，底层攒好树结构后向上层返回子树的root，上层把子树的root加挂在自己的下面后继续向上递交。


### Populating Next Right Pointers in Each Node

https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/994/

这个题有多种解法，题目要求要在O(1)空间复杂度内做出。

方法一：递归

```
class Solution:
    # @param root, a tree link node
    # @return nothing
    def connect(self, root):
        if root == None:
            return None
        if root.left:
            root.left.next = root.right
        if root.right:
            if root.next:
                root.right.next = root.next.left
            else:
                root.right.next = None
        self.connect(root.left)
        self.connect(root.right)
        
```
这个方法的思路是，拿到一个node，把下一层的node串起来。由于是完全二叉树，左孩子有则必有右孩子，所有left可以直接next指向right。至于right，要先看父节点的next有没有，如果有，right的next就指向父节点next的left，否则指向none。

完成一个节点后，开始递归调用，把这个节点的左右孩子传入进去即可。

方法二：迭代


```
class Solution:
    # @param root, a tree link node
    # @return nothing
    def connect(self, root):
        
        if root == None:
            return
        
        start = root
        cur = None
        
        while(start.left):
            
            cur = start
            
            while(cur):
                cur.left.next = cur.right
                if cur.next:
                    cur.right.next = cur.next.left
                    
                cur = cur.next # 后移遍历本层的所有node
                
            start = start.left # 向下继续找最左侧开始的地方
```

这个是上面递归的迭代版本，是真正做到了O(1)复杂度的。
整体思路为，外层循环一直在左侧找开始，内层循环和上面的递归类似，只不过多了一个cur=cur.next用来不断后移这一层的cur

方法三：队列


```
class Solution:
    # @param root, a tree link node
    # @return nothing
    def connect(self, root):
        
        queue = [root, None]
        while True:
            cur = queue[0]
            queue.pop(0)
            if cur:
                cur.next = queue[0]
                if cur.left:
                    queue.append(cur.left)
                if cur.right:
                    queue.append(cur.right)
            else:
                if len(queue) == 0 or queue[0] == None:
                    return 
                queue.append(None)
```
这个方法不太符合要求，因为开辟了多余的空间。
此方法巧妙之处在于使用了none为分割标记，这样就可以区分出层了。当队列中取出的元素时none时，代表上一层所有节点已经全部用完，不能再继续扩展了，因此队列中要加入一个none表示下层的扩展结束。

### Populating Next Right Pointers in Each Node II

https://leetcode.com/explore/learn/card/data-structure-tree/133/conclusion/1016/

```
class Solution:
    # @param root, a tree link node
    # @return nothing
    def connect(self, root):
        
        dummy = TreeLinkNode(0)
        curr = dummy
        
        while(root):
            if root.left:
                curr.next = root.left
                curr = curr.next
            if root.right:
                curr.next = root.right
                curr = curr.next
            root = root.next
            if root == None:
                curr = dummy
                root = dummy.next
                dummy.next = None
```

note：
1. 这里不再是完全二叉树，因此存在左孩子有右孩子就一定有这个条件了。
2. 设置一个dummy来记录每一层的开始位置，dummy.next指向每一层的第一个node
3. 注意，进入循环之前，dummy和curr是一个东西，因此curr.next=root.left/right实际上已经标明dummy.next是root.left或者right了,之后curr = curr.next，curr不再是dummy，因此dummy的就保住了。
4. root不断后移，直到none后，说明本层结束，root要更新成下一层的开始，也就是之前保住的dummy.next，然后把它清空
5. 主体思路还是遍历一层，连接他的下一层，和之前差别不大。


### 最低公共祖先


```
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        
        if root == None or root == p or root == q:
            return root
        
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        
        if left and right:
            return root
        else:
            if left == None:
                return right
            if right == None:
                return left
```

### Smallest Subtree with all the Deepest Nodes

> Given a binary tree rooted at root, the depth of each node is the shortest distance to the root.
> A node is deepest if it has the largest depth possible.
> Return the node with the largest depth such that it contains all the deepest nodes in it's subtree.

```
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    
    
    def subtreeWithAllDeepest(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        
        d = {}
        
        def dfs(node, d, dep):
            
            if node.left == None and node.right == None:
                d[node] = dep
                return node
            
            if node.left == None:
                return dfs(node.right, d, dep+1)
            
            if node.right == None:
                return dfs(node.left, d, dep+1)
            
            leftAns = dfs(node.left, d, dep+1)
            rightAns = dfs(node.right, d, dep+1)
            
            if d[leftAns] == d[rightAns]:
                d[node] = d[leftAns]
                return node
            else:
                if d[leftAns] > d[rightAns]:
                    return leftAns
                else:
                    return rightAns
            
        ans = dfs(root, d, 1)
        return ans
```
note：
1. 这是一道bottom up和top down结合的题目
2. 使用一个字典记录下叶子node的深度，注意，这里只有叶子node才有可能是最大深度node
3. 左右两边同时递归，递归的结果是，如果左右子树返回的节点深度一样，说明当前节点包含了他们，因此在字典中更新本层节点到该深度，向上返回
4. 如果深度不一样，则返回那个更大的


## 哈希相关

### hash set

#### Happy Number

https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1131/


```
class Solution:
    def isHappy(self, n):
        """
        :type n: int
        :rtype: bool
        """
        strNum = str(n)
        sum = 0
        hashset = set()
        while True:
            for char in strNum:
                sum += int(char)*int(char)
            if sum == 1:
                return True
            elif sum in hashset:
                return False
            else:
                hashset.add(sum)
                strNum = str(sum)
                sum = 0
```
Note:
本题关键在于如何判断陷入了死循环。显然，如果在计算过程中遇到了之前就计算得到的结果，那么就会陷入死循环，因此维护一个set，记录已经出现的sum，后面一一比较即可。

### two sum


```
class Solution:
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        
        hashmap = {}
        for index, num in enumerate(nums):
            other = target-num
            if other in hashmap:
                return [hashmap[other], index]
            else:
                hashmap[num] = index
```

Note:
1. hashmap比hashset多一个好处在于，他可以储存额外信息，这个题目中index就是额外信息。如果不返回index，只需要判断是否有这样的加和对存在，hashset即可。
2. 用hashmap减少一层循环的工作量，先算出当前num的补数，然后去hashmap里查有没有对应的，有就提出他的index，没有就把当前num加入hashmap



###  Isomorphic Strings


```
class Solution:
    def isIsomorphic(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: bool
        """
        hashmap = {}
        n = len(s)
        for i in range(n):
            if s[i] not in hashmap:
                hashmap[s[i]] = t[i]
            else:
                if hashmap[s[i]] != t[i]:
                    return False
        hashmap.clear()
        for i in range(n):
            if t[i] not in hashmap:
                hashmap[t[i]] = s[i]
            else:
                if hashmap[t[i]] != s[i]:
                    return False
        return True
```

note：
1. 这里对应关系是一个双向映射关系，因此需要确保从s到t和t到s都是一一映射
2. 两种办法，一种是走两遍循环，用一个hashmap，一个是开两个hashmap，走一遍循环。


### Minimum Index Sum of Two Lists

https://leetcode.com/explore/learn/card/hash-table/184/comparison-with-other-data-structures/1177/


```
class Solution:
    def findRestaurant(self, list1, list2):
        """
        :type list1: List[str]
        :type list2: List[str]
        :rtype: List[str]
        """
        
        hashmap = {}
        ans = []
        
        for index, item in enumerate(list1):
            hashmap[item] = index
            
        sumMin = 1000000
        for index, item in enumerate(list2):
            if item in hashmap:
                sumIndex = index+hashmap[item]
                if sumIndex < sumMin:
                    sumMin = sumIndex
                    ans.clear()
                    ans.append(item)
                elif sumIndex == sumMin:
                    ans.append(item)
        return ans
                      
```

note
1. 找公共集合，而且要找index之和最小的，因此需要用hashmap记录额外信息index。
2. 应该一遍循环找sumMin，一遍循环确定公共集合，因为公共的集合不一定唯一。
3. 一遍循环搞定，一边循环一边找sumMin，当发现了比当前sumMin还小的组合的时候，意味着ans里记录的答案全错，clear后重新记录答案。


### First Unique Character in a String


```
class Solution:
    def firstUniqChar(self, s):
        """
        :type s: str
        :rtype: int
        """
        if s == "":
            return -1
        hashmap = {}
        for char in s:
            if char in hashmap:  
                hashmap[char] += 1
            else:
                hashmap[char] = 1
        
        for index, char in enumerate(s):
            if hashmap[char] == 1:
                return index
        
        return -1
```
note：
1. hashmap记录的额外信息是字母出现的频数


### Intersection of Two Arrays II

https://leetcode.com/explore/learn/card/hash-table/184/comparison-with-other-data-structures/1178/


```
class Solution:
    def intersect(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[int]
        """
        hashmap = {}
        for num in nums1:
            if num in hashmap:
                hashmap[num] += 1
            else:
                hashmap[num] = 1
        
        ans = []
        for num in nums2:
            if num in hashmap and hashmap[num] != 0:
                ans.append(num)
                hashmap[num] -= 1
        
        return ans
```

note：
1. 和上一个题类似，用hashmap记录频数这一额外信息。

类似题：Jewels and Stones

https://leetcode.com/explore/learn/card/hash-table/187/conclusion-hash-table/1136/


```
class Solution:
    def numJewelsInStones(self, J, S):
        """
        :type J: str
        :type S: str
        :rtype: int
        """
        counter = collections.Counter()
        for stone in S:
            counter[stone] += 1
        
        ans = 0
        for jewel in J:
            if jewel in counter:
                ans += counter[jewel]
        return ans
```



### Contains Duplicate II

https://leetcode.com/explore/learn/card/hash-table/184/comparison-with-other-data-structures/1121/

```
class Solution:
    def containsNearbyDuplicate(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: bool
        """
        hashmap = {}
        for index, num in enumerate(nums):
            if num in hashmap and abs(hashmap[num] - index) <= k:
                return True
            else:
                hashmap[num] = index
        return False
```
note:
1. hashmap记录index信息，每次遍历去hashmap中查是否有这个数，如果有，是否满足下标差小于k的要求。

### Group Anagrams

https://leetcode.com/explore/learn/card/hash-table/185/hash_table_design_the_key/1124/

```
class Solution:
    def groupAnagrams(self, strs):
        """
        :type strs: List[str]
        :rtype: List[List[str]]
        """
        
        
        def strSort(word):
            return "".join((lambda x:(x.sort(),x)[1])(list(word)))
        
        sortedWords = []
        ans = {}
        for word in strs:
            sortedWords.append(strSort(word))
        
        for i in range(len(strs)):
            if sortedWords[i] not in ans:
                ans[sortedWords[i]] = [strs[i]]
            else:
                ans[sortedWords[i]].append(strs[i])

        return list(ans.values())
```
note:
1. 关键在于要把原有字符串排序，这样不同的组合就能映射到同一个key了
2. dict可以使用list作为value，但是key好像不能hash
3. 扫描的是排序后的字符串数组，但是实际上装入的是原始字符串数组。


### Find Duplicate Subtrees

https://leetcode.com/explore/learn/card/hash-table/185/hash_table_design_the_key/1127/


```
class Solution:
    def findDuplicateSubtrees(self, root):
        """
        :type root: TreeNode
        :rtype: List[TreeNode]
        """
        counter = collections.Counter()
        ans = []
        
        def collect(node):
            if not node:
                return '#'
            key = "{}, {}, {}".format(node.val, collect(node.left), collect(node.right))
            counter[key] += 1
            if counter[key] == 2:
                ans.append(node)
            return key
        
        collect(root)
        
        return ans
```
note
1. 这个题的难度在于如何选择一种key可以唯一表示一棵树，另外如何遍历到所有的subtree。
2. key可以选择序列化tree的操作，具体参考链接 https://leetcode.com/problems/find-duplicate-subtrees/solution/
3. 如何遍历选择dfs，这是一个bottom up的过程，当遍历到叶子节点，就返回#，交给上层，上层拿到下层的返回序列化key，构造自己subtree的key，然后加入hashmap。同时检查hashmap是否出现重复。
4. hashmap采用了collection的counter，更多信息参考 https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001411031239400f7181f65f33a4623bc42276a605debf6000


解法二：

```
class Solution:
    def findDuplicateSubtrees(self, root):
        """
        :type root: TreeNode
        :rtype: List[TreeNode]
        """
        trees = collections.defaultdict()
        trees.default_factory = trees.__len__
        counter = collections.Counter()
        ans = []
        def lookup(node):
            if node:
                uid = trees[node.val, lookup(node.left), lookup(node.right)]
                counter[uid] += 1
                if counter[uid] == 2:
                    ans.append(node)
                return uid
        
        lookup(root)
        return ans
        
```
note：
1. 类似于上面的解法，也是要找一个合适key，这次找的是node.val node.left和node.right
2. 这个方法的巧妙在于，上面的方法要形成一个key，复杂度是O（n^2）,因为需要遍历一下tree，还要把每个subtree序列化一遍。这个方法优化了这一步，直接用一个hash表示subtree，每个subtree仅仅和孩子节点的key有关。因此复杂度是O（n）
3. 注意node一定要是val，只需要val一样，subtree就认为是相同的，如果是加入node对象，每一个node都是不同的，也就没有答案了。
4. 这里还是bottom up的思路，底层subtree用自己的left和right以及自身的val形成了一个唯一的uid，交到上层，上层继续用这个形成自己的uid


### Longest Substring Without Repeating Characters


```
class Solution:
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        usedChar = {}
        maxlen = 0
        start = 0
        for i in range(len(s)):
            if s[i] in usedChar and start <= usedChar[s[i]]:
                start = usedChar[s[i]]+1
            else:
                maxlen = max(maxlen, i-start+1)
            usedChar[s[i]] = i
        return maxlen
```
note：
1. 需要使用hashmap来记录index这个额外信息。
2. 如果一个字符已经被使用过，那么下一次就要从被使用过的字符的下一个继续搜索。
3. 循环每次都要记录最新字符出现的位置

### Top K Frequent Elements


```
class Solution(object):
    def topKFrequent(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        
        d = {}
        ans = []
        for num in nums:
            if num not in d:
                d[num] = 1
            else:
                d[num] += 1
        
        sortD = sorted(d.items(), key=lambda x:x[1], reverse=True)
        for i in range(k):
            ans.append(sortD[i][0])
        return ans
        
```
note：
1. 简单题，hashmap统计频数即可，但是要注意怎么对字典排序。


###  4Sum II

https://leetcode.com/explore/learn/card/hash-table/187/conclusion-hash-table/1134/

```
class Solution:
    def fourSumCount(self, A, B, C, D):
        """
        :type A: List[int]
        :type B: List[int]
        :type C: List[int]
        :type D: List[int]
        :rtype: int
        """
        
        d1 = {}
        for num1 in A:
            for num2 in B:
                sumNum = num1+num2
                if sumNum in d1:
                    d1[sumNum] += 1
                else:
                    d1[sumNum] = 1
        d2 = {}
        for num1 in C:
            for num2 in D:
                sumNum = num1+num2
                if sumNum in d2:
                    d2[sumNum] += 1
                else:
                    d2[sumNum] = 1
        
        ans = 0
        for key,val in d1.items():
            if -key in d2:
                ans += d2[-key] * val
        
        return ans
```
note:
1. 暴力思路是四重循环
2. 优化一步是在最后一重循环用hash，复杂度n^3
3. 当前做法是，两个list求一次和，存到hashmap里，然后检查另一个hashmap里是否有相反数
4. 如果有，则需要把两边记录的频数相乘，这是乘法原理，相当于sum=key有n中可能，另外一个hash对的-key的有m种可能，总的加起来和为0的可能输就是m*n


## 栈 stack

### Score of Parentheses

Given a balanced parentheses string S, compute the score of the string based on the following rule:

- () has score 1
- AB has score A + B, where A and B are balanced parentheses strings.
- (A) has score 2 * A, where A is a balanced parentheses string.



```
class Solution:
    def scoreOfParentheses(self, S):
        """
        :type S: str
        :rtype: int
        """
        stack = []
        
        for c in S:
            if c == "(":
                stack.append(-1) # 以-1作为标记
            else:
                cur = 0
                while(stack[-1] != -1):  # 把配对之前的分数都加起来
                    cur += stack.pop()
                stack.pop()  # 跑掉当前）配对的（代表的-1
                if cur == 0:  # 如果没有中间的分数，证明是直接配对的括号，1分
                    stack.append(1)
                else:
                    stack.append(cur*2)  # 用中间配对的分数，加倍
        
        ans = 0
        while len(stack) != 0:  # 遍历分数栈，可能会有多个分散的括号组合，因此加和
            ans += stack.pop()
        
        return ans
```


## 二叉搜索树 BST

### Validate Binary Search Tree

解法一

```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        import sys
        def bottomup(node, minNum, maxNum):
            if node == None:
                return True
            if node.val <= minNum or node.val >= maxNum:
                return False
            left = bottomup(node.left, minNum, node.val)
            right = bottomup(node.right, node.val, maxNum)
            return left and right
        
        ans = bottomup(root, -sys.maxsize -1, sys.maxsize)
        return ans
```

note:
1. bottom up思路，从叶子节点向上逐层提交结果。
2. 验证的时候要维护最大值和最小值，递归更新的时候，本层的node节点的值对于left 子树来说就是最大的，对于right 子树来说就是最小的。
3. 递归的时候检查是否满足BST条件，注意，BST要求左子树所有节点都要比本层node小，右子树所有节点都要比本层node大，而不是仅仅左右节点的值。

解法二


```
class Solution:
    def isValidBST(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        self.pre = None
        
        def inorder(node):
            
            if node != None:

                if (not inorder(node.left)):
                    return False

                if self.pre != None and self.pre.val >= node.val:
                    return False

                self.pre = node

                return inorder(node.right)
            
            return True
        
        ans = inorder(root)
        return ans
```
note：
1. 采用中序遍历的思路，BST的中序遍历应该是一个递增的数组，这里题目也排除了相等关系，因此不会有歧义。
2. 不开数组也可以做，中序遍历依次比较前一个和当前节点的大小关系，如果违反了就判定为false

### Binary Search Tree Iterator

https://leetcode.com/explore/learn/card/introduction-to-data-structure-binary-search-tree/140/introduction-to-a-bst/1008/

```

class BSTIterator(object):
    def __init__(self, root):
        """
        :type root: TreeNode
        """
        self.stack = []
        p = root
        while p:
            self.stack.append(p)
            p = p.left
        

    def hasNext(self):
        """
        :rtype: bool
        """

        return len(self.stack) != 0
        

    def next(self):
        """
        :rtype: int
        """
        
        p = self.stack.pop()
        val = p.val
        
        if p.right:
            p = p.right
            self.stack.append(p)
            p = p.left
            while p:
                self.stack.append(p)
                p = p.left
        
        return val
```
note：
1. 最小的节点一定是最left的，如何在找到left节点后追溯到父节点，使用栈数据结构来存储。
2. stack先沿着最左边left的路径的node入栈
3. next的时候直接弹出栈顶元素，这个就是要返回的节点值，但是注意此时要更新栈，更新的方法是，先看弹出的node有没有right，因为这个已经是left到底了，所以不可能再用left了。如果还没有right，说明是个叶子node，无须更新栈，如果是有right的，继续沿着这个node的left线路入栈

### Search in a Binary Search Tree

递归法

```

class Solution(object):
    def searchBST(self, root, val):
        """
        :type root: TreeNode
        :type val: int
        :rtype: TreeNode
        """
        
        if root == None:
            return
        if root.val == val:
            return root
        elif root.val > val:
            return self.searchBST(root.left, val)
        else:
            return self.searchBST(root.right, val)
```

迭代法


```
class Solution(object):
    def searchBST(self, root, val):
        """
        :type root: TreeNode
        :type val: int
        :rtype: TreeNode
        """
        
        p = root
        while p:
            if p.val == val:
                return p
            elif p.val > val:
                p = p.left
            else:
                p = p.right
        else:
            return None
```

note：
1. 从上向下搜索，如果当前node大于target，左子树中去找，否则右子树去找。


### Insert into a Binary Search Tree

递归法

```
class Solution(object):
    def insertIntoBST(self, root, val):
        """
        :type root: TreeNode
        :type val: int
        :rtype: TreeNode
        """
        
        if root == None:
            root = TreeNode(val)
            return root
        elif root.val < val:
            root.right = self.insertIntoBST(root.right, val)
            return root
        elif root.val > val:
            root.left = self.insertIntoBST(root.left, val)
            return root
```

迭代法


```
class Solution(object):
    def insertIntoBST(self, root, val):
        """
        :type root: TreeNode
        :type val: int
        :rtype: TreeNode
        """
        
        p = root
        if p == None:
            root = TreeNode(val)
            return root
        
        while p:
            if p.val < val:
                if p.right == None:
                    p.right = TreeNode(val)
                    return root
                p = p.right
            else:
                if p.left == None:
                    p.left = TreeNode(val)
                    return root
                p = p.left
```
note:
1. 本质是寻找叶子node，加挂的node一定可以加在某个叶子node上？
2. 如果当前的node值小于要插入的值，而且当前node没有right，所以新的值应该就可以被挂在right上，left分析类似。

### Delete Node in a BST


```
class Solution:
    def deleteNode(self, root, key):
        """
        :type root: TreeNode
        :type key: int
        :rtype: TreeNode
        """
        
        def getsmallest(node):
            p = node
            while p.left:  # 这里必须是left，因为p如果是none停下，就没有val属性了 
                p = p.left
            return p.val
        
        if root == None:
            return None
        
        if root.val == key:
            if root.left == None and root.right == None:
                return None
            elif root.left == None:
                return root.right
            elif root.right == None:
                return root.left
            else:
                root.val = getsmallest(root.right)  # 把当前节点替换成右子树的最小node的值，也就是中序遍历紧跟着的那个值
                root.right = self.deleteNode(root.right, root.val)  # 这一步把替换值传入，为的是把后面这个节点删去
        
        
        elif root.val > key:
            root.left = self.deleteNode(root.left, key)
        
        else:
            root.right = self.deleteNode(root.right, key)
        
        return root
```
note：
1. 分情况讨论，如果要删除的节点没有child，直接删除
2. 如果要删除的node有其中一个child，用child替换这个node
3. 如果两个child都有，需要把subtree里中序遍历里紧跟着这个node的val替换他，然后再去掉这个node。


### Lowest Common Ancestor of a Binary Search Tree


```
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        if root == None:
            return 
        if root.val > max(p.val, q.val):
            return self.lowestCommonAncestor(root.left, p, q)
        elif root.val < min(p.val, q.val):
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root
```
note：
1. 如果当前node的值比p和q都要大，说明这个最低公共祖先肯定在左子树里，右子树分析同理。
2. 这里由于是BST，可以借助这个性质，一般的BT就不可以了。

### Contains Duplicate III

https://leetcode.com/explore/learn/card/introduction-to-data-structure-binary-search-tree/142/conclusion/1013/

```
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
        multiset<long long> bst;
        for (int i = 0; i < nums.size(); ++i) {
            if (bst.size() == k + 1) bst.erase(bst.find(nums[i - k - 1]));
            auto lb = bst.lower_bound(nums[i]);
            if (lb != bst.end() && abs(*lb - nums[i]) <= t) return true;
            auto ub = bst.upper_bound(nums[i]);
            if (ub != bst.begin() && abs(*(--ub) - nums[i]) <= t) return true;
            bst.insert(nums[i]);
        }
        return false;
    }
};
```
note：
1. 维护一个大小为k的二叉搜索树，这个BST相当于一个滑动窗口，其中所有的元素都可以满足下标差距在k内的要求。
2. 检验其中的元素是否满足值大小的要求，这里用到了lower bound和upper bound来搜索。
3. 继续向前滚动，加入新的元素，bst的插入删除惭怍都是logn的复杂度，因此效率很高。


### Kth Largest Element in a Stream

TLE

```
class KthLargest(object):

    def __init__(self, k, nums):
        """
        :type k: int
        :type nums: List[int]
        """
        from heapq import *
        self.heap = nums
        #for num in nums:
        heapify(self.heap)
        self.k = k
        

    def add(self, val):
        """
        :type val: int
        :rtype: int
        """
        from heapq import *
        if len(self.heap) <= self.k:
            heappush(self.heap, val)
        else:
            if val > self.heap[0]:
                heapreplace(self.heap, val)
        return nlargest(self.k, self.heap)[-1]
        


# Your KthLargest object will be instantiated and called as such:
# obj = KthLargest(k, nums)
# param_1 = obj.add(val)
```
note：
1. 维护一个大小为k的heap或者bst，大小超过k前一直把新来的元素加入即可
2. 超过k后，要比较新来的元素和heap中最小的元素的关系，如果比最小元素还小，就不可能是前k大的，因此不加入，满足条件的可以插入。
3. 返回的就是第k大的数字，所有操作都能在logn内完成。
4. 关于堆的简单知识补充 https://www.cnblogs.com/JVxie/p/4859889.html
5. 关于python中heapq补充： https://www.cnblogs.com/chang1203/p/6537345.html

### Balanced Binary Tree


```
class Solution(object):
    def isBalanced(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        def dfs(node):
            
            if node == None:
                depth = 0
                return True, depth
            
            left, leftDep = dfs(node.left)
            right, rightDep = dfs(node.right)
            
            if  left and right:
                diff = abs(leftDep-rightDep)
                if diff <= 1:
                    depth = 1 + max(leftDep, rightDep)
                    return True, depth
            return False, 0
            
        ans, depth = dfs(root)
        return ans
```
note：
1. bottom up思路，subtree逐层向上提交自己是否是平衡树的判断结果。
2. 同时向上提交的还有本层的depth，方便上层node来判断自己是不是平衡的。
3. 递归的出口在叶子节点下层，一旦遍历到none，深度设置为0，返回true

### Convert Sorted Array to Binary Search Tree


```
class Solution:
    def sortedArrayToBST(self, nums):
        """
        :type nums: List[int]
        :rtype: TreeNode
        """
        
        def buildTree(nums, low, high):
            
            if low > high:  # 这里不能有等于，当low和high相遇时，mid就是low和high本身的node，这个也要加入到tree中
                return None
            
            mid = (low+high)//2
            root = TreeNode(nums[mid])
            root.left = buildTree(nums, low, mid-1)
            root.right = buildTree(nums, mid+1, high)
            
            return root
        
        return buildTree(nums, 0, len(nums)-1)
```
note：
1. 从数组的二分之一处开始建树，然后递归二分地继续调用这个过程+
2. 



## 链表

### Linked List Cycle

```
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        pfast = head
        pslow = head
        
        if pfast == None:
            return False
        
        while pfast != None and pfast.next != None:
            pfast = pfast.next.next
            pslow = pslow.next
            if pfast == pslow:
                return True
        return False
        
```
note：
1. 思路很简单，快慢指针
2. 注意，fast指针是循环结束的条件，fast一次走两步，因此判断fast本身是不是空以及fast.next是不是空很重要。slow因为比fast慢，因此肯定不会在fast空之前为空。

###  Intersection of Two Linked Lists


```
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def getIntersectionNode(self, headA, headB):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        """
        n1 = 0
        p = headA
        while p != None:
            p = p.next
            n1 += 1
        
        n2 = 0
        p = headB
        while p != None:
            p = p.next
            n2 += 1
        
        p1 = headA
        p2 = headB
        if n1 >= n2:
            for i in range(n1-n2):
                p1 = p1.next
        else:
            for i in range(n2-n1):
                p2 = p2.next
        while (p1 != p2):
            p1 = p1.next
            p2 = p2.next
            
        return p1
        
```
note：
1. 统计一下两个链表的长度，让长的链表node先走多出来那些步，然后两个指针一起走，汇合点就是合并点。


###  Remove Nth Node From End of List

https://leetcode.com/explore/learn/card/linked-list/214/two-pointer-technique/1296/

```
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def removeNthFromEnd(self, head, n):
        """
        :type head: ListNode
        :type n: int
        :rtype: ListNode
        """
        dummy = ListNode(0)
        dummy.next = head
        
        fast = dummy
        slow = dummy
        for i in range(n):
            fast = fast.next
        while fast.next != None:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        
        return dummy.next
```
note：
1. 基本思路是快慢指针，快指针先走n步，然后再和满指针一起走。
2. 快指针停止条件是fast.next为空，此时slow指向的是要移除节点的前一个，这样便于操作。
3. 这里有一个trick，如果要移除头结点，直接做很难处理，此时不妨加入一个哑变量dummy，让他当作头部，这样代码无论移除的是正常节点还是头结点，都是统一的，因此返回dummy.next就好了


### Linked List Cycle II

https://leetcode.com/explore/learn/card/linked-list/214/two-pointer-technique/1214/

```
class Solution(object):
    def detectCycle(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        pfast = head
        pslow = head
        
        if pfast == None:
            return None
        
        step_slow  = 0
        
        while pfast != None and pfast.next != None:
            
            pfast = pfast.next.next
            pslow = pslow.next
            step_slow += 1
            
            if pfast == pslow:
                diff = step_slow
                p1 = head
                p2 = head
                for i in range(diff):
                    p1 = p1.next
                while p1 != p2:
                    p1 = p1.next
                    p2 = p2.next
                return p1         
        else:
            return None
        
```
note：
1. 如果有环，两个指针相遇的时候，pfast应该走的是pslow的两倍
2. 多出来哪一倍，就是环的长度。
3. 此时再设置两个指针，一个指针先走完环的长度，两个指针再一起走，汇合点就是环的起点。


### Reverse Linked List


```

class Solution(object):
    def reverseList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        prev = None
        p = head
        pNewHead = None
        
        while(p != None):
            
            nextNode  = p.next
            if nextNode == None:
                pNewHead = p
            p.next = prev
            prev = p
            p = nextNode
        
        return pNewHead
            
```
1. 翻转链表，写一次忘一次，算了直接背过吧。。。。
2. 设计三个指针，一个之前的，一个当前的，还有一个准备当作新的head
3. 进入循环第一步，拿到下一个node，因为当前的next翻转后就找不到下一个node了
4. 翻转指针后，pre后移，当前的p也要后移


### Remove Linked List Elements

https://leetcode.com/explore/learn/card/linked-list/219/classic-problems/1207/


```
class Solution(object):
    def removeElements(self, head, val):
        """
        :type head: ListNode
        :type val: int
        :rtype: ListNode
        """
        dummy = ListNode(0)
        dummy.next = head
        
        pre = dummy
        p = dummy.next
        
        while p != None:
            if p.val == val:
                pre.next = p.next
                p = pre.next
            else:
                p = p.next
                pre = pre.next
                
        return dummy.next
```
note：
1. 思路是遇到val是目标数的node删除即可。
2. 因为涉及到删除，所以要维护一个pre之前的node
3. 因为可能涉及到删除头结点，为了统一操作，仍然使用dummy 的trick。

### Odd Even Linked List

https://leetcode.com/explore/learn/card/linked-list/219/classic-problems/1208/


```
class Solution(object):
    def oddEvenList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        
        if head == None or head.next == None:
            return head
        
        oddHead = head
        evenHead = head.next
        p1 = oddHead
        p2 = evenHead
        while p2 and p2.next:
            p1.next = p2.next
            p1 = p1.next
            p2.next = p1.next
            p2 = p2.next
        p1.next = evenHead
            
        return oddHead
```

note：
1. 基本思路是，偶数位置穿一串，奇数位置穿一串，然后连起来就可以了
2. p1 = p1.next要首先后移，因为后面p2要继续向后再找一个next，p1这时要跑到p2的后面才行。


###  Palindrome Linked List


```
class Solution(object):
    def isPalindrome(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        
        if head == None:
            return True
        
        fast = head
        slow = head
        
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        
        mid = slow
        pre = None
        newHead = None
        
        while mid != None:
            nextnode = mid.next
            if nextnode == None:
                newHead = mid
            mid.next = pre
            pre = mid
            mid = nextnode
        
        p1 = newHead
        p2 = head
        
        while p1 != None and p2 != None and p1.val == p2.val:
            p1 = p1.next
            p2 = p2.next
        
        return p1 is None
```
note：
1. 基本思路是先找中间点，从中间点开始把后面的翻转，然后从两边向中间比较。
2. 找中点的思路是快慢指针，fast每次2步，slow每次一步，当fast停下时，slow就是中间点。
3. 翻转和上面链表翻转完全一样

### Merge Two Sorted Lists


```
class Solution(object):
    def mergeTwoLists(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        
        p1 = l1
        p2 = l2
        p = None
        if p1 == None:
            return p2
        elif p2 == None:
            return p1
        if p1.val < p2.val:
            p = p1
            p.next = self.mergeTwoLists(p1.next,p2)
        else:
            p = p2
            p.next = self.mergeTwoLists(p1,p2.next)
        return p
        
```
note：
1. 基本思路是，拿出两个链表的头结点，比较大小，把小的取出，作为新的node，后面继续加挂。
2. 后续加挂的操作和之前是一样的，所以是递归的。
3. 考虑其中一个链表走完之后，要返回另一个链表的node

### Add Two Numbers

https://leetcode.com/explore/learn/card/linked-list/213/conclusion/1228/


```
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        
        p1 = l1
        p2 = l2
        
        carry = 0
        
        dummy = ListNode(0)
        lastNode = dummy
        
        while p1 or p2:
            
            if p1 and p2:
                sumNum = p1.val + p2.val
                p1 = p1.next
                p2 = p2.next
            elif p1 == None and p2 != None:
                sumNum = p2.val
                p2 = p2.next
            elif p1 != None and p2 == None:
                sumNum = p1.val
                p1 = p1.next
                
            num = (sumNum+carry) % 10 
            carry = (sumNum+carry) / 10
            
            node = ListNode(num)
            lastNode.next = node
            lastNode = node
        
        if carry != 0:
            node = ListNode(carry)
            lastNode.next = node
            
        return dummy.next
```

note：
1. 首先要检验哪一个链表走到了空
2. 设置进位标志carry
3. 计算到最后如果carry不为0，说明还要拓展一位，最后需要处理这种情况。


### Flatten a Multilevel Doubly Linked List

https://leetcode.com/explore/learn/card/linked-list/213/conclusion/1225/

```
class Solution(object):
    def flatten(self, head):
        """
        :type head: Node
        :rtype: Node
        """

        p = head

        while p:
            nextNode = None
            if p.child:
                nextNode = p.next
                p.child.prev = p
                p.next = self.flatten(p.child) # 把child的链表挂上去
                p.child = None
                
                if nextNode != None:  # 如果child后面有节点
                    cur = p.next      # 走完child链表
                    while cur.next:
                        cur = cur.next
                    cur.next = nextNode  #  把后续链表加挂到child后面
                    nextNode.prev = cur
                cur = nextNode
                
            else:
                p = p.next
            
        return head
```
note：


### Rotate List

https://leetcode.com/explore/learn/card/linked-list/213/conclusion/1295/


```
class Solution(object):
    def rotateRight(self, head, k):
        """
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        """
        
        p = head
        
        if p == None:
            return None
        
        cnt = 0
        while p:
            cnt += 1
            p = p.next
        
        s = k % cnt
        
        if s == 0:
            return head
        
        p1 = head
        p2 = head
        for i in range(s):
            p1 = p1.next
        
        while p1.next:
            p1 = p1.next
            p2 = p2.next
        
        newHead = p2.next
        p2.next = None
        p1.next = head
        
        return newHead
        
```
note：
1. 这里的思路是，先算出链表长度，然后对k对长度取模，取模之后的长度其实就是要把链表后面多少个node搬运到前半部，后面用快慢指针找到搬运的起始点，加挂到前半部即可。
2. 细节，这个方法head为空需要特殊处理
3. 细节，这个方法如果s算出来时0需要特殊处理
4. 快慢指针，循环停止条件是p1.next为空，此时p1停在了最后一个节点上，可以挂上前半部的链表，p2停在了旋转点上，可以拆下来作为新的head


### Copy List with Random Pointer

https://leetcode.com/explore/learn/card/linked-list/213/conclusion/1229/


```
class Solution(object):
    def copyRandomList(self, head):
        """
        :type head: RandomListNode
        :rtype: RandomListNode
        """
        
        d = {}
        if head == None:
            return head
        
        p = head
        while p:
            newNode = RandomListNode(p.label)
            d[p] = newNode
            p = p.next
        
        p = head
        while p:
            d[p].next = d[p.next] if p.next else None
            d[p].random = d[p.random] if p.random else None
            
            p = p.next
        
        return d[head] if head else None
```

note：
1. 基本思路是用一个hashmap把新旧链表对应关系存起来，然后第二遍循环加挂指针关系。
2. d[p].next是新node的指针，是需要加挂的对象，指针指向的应该是新的node，也就是d[p.next]，其中p是老节点，p.next就是老节点的下一个，查找hashmap中就是对应的新节点的下一个了，random同理。


## Array and String

###  Find Pivot Index

https://leetcode.com/explore/learn/card/array-and-string/201/introduction-to-array/1144/


```
class Solution:
    def pivotIndex(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        total = sum(nums)
        
        ind = 0
        indsum = 0
        for ind in range(0,len(nums)):
            rightsum = total - nums[ind] - indsum
            if indsum == rightsum:
                return ind
            indsum += nums[ind]
        
        return -1
```
note：
1. 如果遍历每个位置，然后再算两边的和，复杂度是n^2
2. 应该先求出总和，维护一个左边和，右边和可以用总和减出来，复杂度就是n了


### Largest Number At Least Twice of Others

https://leetcode.com/explore/learn/card/array-and-string/201/introduction-to-array/1147/

```
class Solution:
    def dominantIndex(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        
        maxNum = max(nums)
        index = 0
        for i in range(len(nums)):
            if nums[i] == maxNum:
                index = i
                del nums[i]
                break
        if len(nums) == 0:
            return index
        else:
            secondMaxNum = max(nums)
            if maxNum >= 2*secondMaxNum:
                return index
            else:
                return -1
        
```
note：
1. 找出最大值，如果最大值是次大值的两倍就满足要求
2. 找出最大值，去掉最大值，再找的max就是次大的。
3. 注意找出最大值以后并去掉，list可能为空


### Plus One


```
class Solution:
    def plusOne(self, digits):
        """
        :type digits: List[int]
        :rtype: List[int]
        """
        carry = 0
        ans = []
        for i in range(0, len(digits))[::-1]:
            print(i)
            if  i == len(digits)-1:
                tmp = (digits[i]+1)%10
                carry = (digits[i]+1)//10
                ans.append(tmp)
                print(tmp)
            else:
                tmp = (digits[i]+carry)%10
                carry = (digits[i]+carry)//10
                ans.append(tmp)
        if carry > 0:
            ans.append(carry)
        ans = ans[::-1]
        return ans
        
```
note：
1. 大模拟，没什么可说的，注意最后的进位即可。


### Pascal's Triangle


```
class Solution:
    def generate(self, numRows):
        """
        :type numRows: int
        :rtype: List[List[int]]
        """
        
        if numRows == 0:
            return []
        
        if numRows == 1:
            return [[1]]
        
        res = []
        last = [1]
        res.append(last)
        last = [0] + last
        last = last + [0]
        
        for i in range(1, numRows):
            curr = []
            for j in range(1, len(last)):
                curr.append(last[j]+last[j-1])
            res.append(curr)
            last = [0] + curr
            last = last + [0]
        return res
        
```
note：
1. 想要生成新的一行，就把上一行的周围补充0，然后从第1个元素开始相邻元素相加即可。


### Longest Common Prefix
 

```
class Solution(object):
    def longestCommonPrefix(self, strs):
        """
        :type strs: List[str]
        :rtype: str
        """
        if len(strs) == 0:
            return ""
        
        lens = [len(string) for string in strs ]
        minLen = min(lens)
        ans = []
        
        index = -1
        for i in range(minLen):
            test = strs[0][i]
            flag = False
            for string in strs[:]:
                if test == string[i]:
                    flag = True
                else:
                    flag = False
                    break
            if flag:
                ans.append(test)
            else:
                break
        return "".join(ans)
        
```
note：
1. 思路不难，就是挨个比较即可，但是其中有一些小坑，注意多个条件判断以及何时跳出循环。


## 动态规划（DP）

