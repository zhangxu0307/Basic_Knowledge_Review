## 二叉搜索树 BST

### Validate Binary Search Tree

解法一

    # Definition for a binary tree node.
    # class TreeNode:
    #     def __init__(self, x):
    #         self.val = x
    #         self.left = None
    #         self.right = None

    class Solution:
        def isValidBST(self, root):
            """
            :type root: TreeNode
            :rtype: bool
            """
            import sys
            def bottomup(node, minNum, maxNum):
                if node == None:
                    return True
                if node.val <= minNum or node.val >= maxNum:
                    return False
                left = bottomup(node.left, minNum, node.val)
                right = bottomup(node.right, node.val, maxNum)
                return left and right
            
            ans = bottomup(root, -sys.maxsize -1, sys.maxsize)
            return ans


note:
1. bottom up思路，从叶子节点向上逐层提交结果。
2. 验证的时候要维护最大值和最小值，递归更新的时候，本层的node节点的值对于left 子树来说就是最大的，对于right 子树来说就是最小的。
3. 递归的时候检查是否满足BST条件，注意，BST要求左子树所有节点都要比本层node小，右子树所有节点都要比本层node大，而不是仅仅左右节点的值。

解法二



    class Solution:
        def isValidBST(self, root):
            """
            :type root: TreeNode
            :rtype: bool
            """
            
            self.pre = None
            
            def inorder(node):
                
                if node != None:

                    if (not inorder(node.left)):
                        return False

                    if self.pre != None and self.pre.val >= node.val:
                        return False

                    self.pre = node

                    return inorder(node.right)
                
                return True
            
            ans = inorder(root)
            return ans

note：
1. 采用中序遍历的思路，BST的中序遍历应该是一个递增的数组，这里题目也排除了相等关系，因此不会有歧义。
2. 不开数组也可以做，中序遍历依次比较前一个和当前节点的大小关系，如果违反了就判定为false

### Binary Search Tree Iterator

https://leetcode.com/explore/learn/card/introduction-to-data-structure-binary-search-tree/140/introduction-to-a-bst/1008/



    class BSTIterator(object):
        def __init__(self, root):
            """
            :type root: TreeNode
            """
            self.stack = []
            p = root
            while p:
                self.stack.append(p)
                p = p.left
            

        def hasNext(self):
            """
            :rtype: bool
            """

            return len(self.stack) != 0
            

        def next(self):
            """
            :rtype: int
            """
            
            p = self.stack.pop()
            val = p.val
            
            if p.right:
                p = p.right
                self.stack.append(p)
                p = p.left
                while p:
                    self.stack.append(p)
                    p = p.left
            
            return val

note：
1. 最小的节点一定是最left的，如何在找到left节点后追溯到父节点，使用栈数据结构来存储。
2. stack先沿着最左边left的路径的node入栈
3. next的时候直接弹出栈顶元素，这个就是要返回的节点值，但是注意此时要更新栈，更新的方法是，先看弹出的node有没有right，因为这个已经是left到底了，所以不可能再用left了。如果还没有right，说明是个叶子node，无须更新栈，如果是有right的，继续沿着这个node的left线路入栈

参考：二叉树中序遍历非递归形式

'''
   # 中序    
    class Solution:
        def inorderTraversal(self, root):
            """
            :type root: TreeNode
            :rtype: List[int]
            """
            
            stack = []
            ans = []
            
            p = root
            
            while p or len(stack) != 0:
                
                while p:
                    stack.append(p)
                    p = p.left
                
                p = stack.pop()
                ans.append(p.val)
                p = p.right
                
            return ans
'''

### Search in a Binary Search Tree

递归法

```

class Solution(object):
    def searchBST(self, root, val):
        """
        :type root: TreeNode
        :type val: int
        :rtype: TreeNode
        """
        
        if root == None:
            return
        if root.val == val:
            return root
        elif root.val > val:
            return self.searchBST(root.left, val)
        else:
            return self.searchBST(root.right, val)
```

迭代法


```
class Solution(object):
    def searchBST(self, root, val):
        """
        :type root: TreeNode
        :type val: int
        :rtype: TreeNode
        """
        
        p = root
        while p:
            if p.val == val:
                return p
            elif p.val > val:
                p = p.left
            else:
                p = p.right
        else:
            return None
```

note：
1. 从上向下搜索，如果当前node大于target，左子树中去找，否则右子树去找。


### Insert into a Binary Search Tree

递归法

```
class Solution(object):
    def insertIntoBST(self, root, val):
        """
        :type root: TreeNode
        :type val: int
        :rtype: TreeNode
        """
        
        if root == None:
            root = TreeNode(val)
            return root
        elif root.val < val:
            root.right = self.insertIntoBST(root.right, val)
            return root
        elif root.val > val:
            root.left = self.insertIntoBST(root.left, val)
            return root
```

迭代法


```
class Solution(object):
    def insertIntoBST(self, root, val):
        """
        :type root: TreeNode
        :type val: int
        :rtype: TreeNode
        """
        
        p = root
        if p == None:
            root = TreeNode(val)
            return root
        
        while p:
            if p.val < val:
                if p.right == None:
                    p.right = TreeNode(val)
                    return root
                p = p.right
            else:
                if p.left == None:
                    p.left = TreeNode(val)
                    return root
                p = p.left
```
note:
1. 本质是寻找叶子node，加挂的node一定可以加在某个叶子node上？
2. 如果当前的node值小于要插入的值，而且当前node没有right，所以新的值应该就可以被挂在right上，left分析类似。

### Delete Node in a BST


```
class Solution:
    def deleteNode(self, root, key):
        """
        :type root: TreeNode
        :type key: int
        :rtype: TreeNode
        """
        
        def getsmallest(node):
            p = node
            while p.left:  # 这里必须是left，因为p如果是none停下，就没有val属性了 
                p = p.left
            return p.val
        
        if root == None:
            return None
        
        if root.val == key:
            if root.left == None and root.right == None:
                return None
            elif root.left == None:
                return root.right
            elif root.right == None:
                return root.left
            else:
                root.val = getsmallest(root.right)  # 把当前节点替换成右子树的最小node的值，也就是中序遍历紧跟着的那个值
                root.right = self.deleteNode(root.right, root.val)  # 这一步把替换值传入，为的是把后面这个节点删去
        
        
        elif root.val > key:
            root.left = self.deleteNode(root.left, key)
        
        else:
            root.right = self.deleteNode(root.right, key)
        
        return root
```
note：
1. 分情况讨论，如果要删除的节点没有child，直接删除
2. 如果要删除的node有其中一个child，用child替换这个node
3. 如果两个child都有，需要把subtree里中序遍历里紧跟着这个node的val替换他，然后再去掉这个node。


### Lowest Common Ancestor of a Binary Search Tree


```
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        if root == None:
            return 
        if root.val > max(p.val, q.val):
            return self.lowestCommonAncestor(root.left, p, q)
        elif root.val < min(p.val, q.val):
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root
```
note：
1. 如果当前node的值比p和q都要大，说明这个最低公共祖先肯定在左子树里，右子树分析同理。
2. 这里由于是BST，可以借助这个性质，一般的BT就不可以了。

### Contains Duplicate III

https://leetcode.com/explore/learn/card/introduction-to-data-structure-binary-search-tree/142/conclusion/1013/

```
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
        multiset<long long> bst;
        for (int i = 0; i < nums.size(); ++i) {
            if (bst.size() == k + 1) bst.erase(bst.find(nums[i - k - 1]));
            auto lb = bst.lower_bound(nums[i]);
            if (lb != bst.end() && abs(*lb - nums[i]) <= t) return true;
            auto ub = bst.upper_bound(nums[i]);
            if (ub != bst.begin() && abs(*(--ub) - nums[i]) <= t) return true;
            bst.insert(nums[i]);
        }
        return false;
    }
};
```
note：
1. 维护一个大小为k的二叉搜索树，这个BST相当于一个滑动窗口，其中所有的元素都可以满足下标差距在k内的要求。
2. 检验其中的元素是否满足值大小的要求，这里用到了lower bound和upper bound来搜索。
3. 继续向前滚动，加入新的元素，bst的插入删除惭怍都是logn的复杂度，因此效率很高。


### Kth Largest Element in a Stream

TLE

```
class KthLargest(object):

    def __init__(self, k, nums):
        """
        :type k: int
        :type nums: List[int]
        """
        from heapq import *
        self.heap = nums
        #for num in nums:
        heapify(self.heap)
        self.k = k
        

    def add(self, val):
        """
        :type val: int
        :rtype: int
        """
        from heapq import *
        if len(self.heap) <= self.k:
            heappush(self.heap, val)
        else:
            if val > self.heap[0]:
                heapreplace(self.heap, val)
        return nlargest(self.k, self.heap)[-1]
        


# Your KthLargest object will be instantiated and called as such:
# obj = KthLargest(k, nums)
# param_1 = obj.add(val)
```
note：
1. 维护一个大小为k的heap或者bst，大小超过k前一直把新来的元素加入即可
2. 超过k后，要比较新来的元素和heap中最小的元素的关系，如果比最小元素还小，就不可能是前k大的，因此不加入，满足条件的可以插入。
3. 返回的就是第k大的数字，所有操作都能在logn内完成。
4. 关于堆的简单知识补充 https://www.cnblogs.com/JVxie/p/4859889.html
5. 关于python中heapq补充： https://www.cnblogs.com/chang1203/p/6537345.html

### Balanced Binary Tree


```
class Solution(object):
    def isBalanced(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        
        def dfs(node):
            
            if node == None:
                depth = 0
                return True, depth
            
            left, leftDep = dfs(node.left)
            right, rightDep = dfs(node.right)
            
            if  left and right:
                diff = abs(leftDep-rightDep)
                if diff <= 1:
                    depth = 1 + max(leftDep, rightDep)
                    return True, depth
            return False, 0  # 注意，这里不能有else，前面两个if都不满足才会触发这一句
            
        ans, depth = dfs(root)
        return ans
```
note：
1. bottom up思路，subtree逐层向上提交自己是否是平衡树的判断结果。
2. 同时向上提交的还有本层的depth，方便上层node来判断自己是不是平衡的。
3. 递归的出口在叶子节点下层，一旦遍历到none，深度设置为0，返回true

### Convert Sorted Array to Binary Search Tree


```
class Solution:
    def sortedArrayToBST(self, nums):
        """
        :type nums: List[int]
        :rtype: TreeNode
        """
        
        def buildTree(nums, low, high):
            
            if low > high:  # 这里不能有等于，当low和high相遇时，mid就是low和high本身的node，这个也要加入到tree中
                return None
            
            mid = (low+high)//2
            root = TreeNode(nums[mid])
            root.left = buildTree(nums, low, mid-1)
            root.right = buildTree(nums, mid+1, high)
            
            return root
        
        return buildTree(nums, 0, len(nums)-1)
```
note：
1. 从数组的二分之一处开始建树，然后递归二分地继续调用这个过程+
2. 

