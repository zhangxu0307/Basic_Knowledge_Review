
## DFS 和 BFS


### Permutations

法一

全排列这个问题很明显是回溯，但是怎么找状态空间是个问题。假设1234是初始的四个数字，如何产生全排列呢？可以把第一个数字1依次与之后的数字交换，会产生一组数字分别为1234、2134、3214、4321。注意，假设1与2交换，变为2134，这又是一个新的数字，可以在此基础上再次进行上述操作，不过这回是从第二个数字开始依次与后面的数字交换，因为再从第一个开始就会又出现1234了，这样2134又会出现2134、2314、2341.如此下去，每个数字都可以这样进行操作。递归的出口就是当进行到最后一个数字时，由于没有后面数字可以交换了，前面的数字交换情况也都有了，于是可以返回。

```
class Solution:
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        import copy
        def dfs(nums, curr, ans):
            if curr == len(nums) - 1:
                ans.append(copy.deepcopy(nums))
                return
            
            for i in range(curr, len(nums)):
                nums[i], nums[curr] = nums[curr], nums[i]
                dfs(nums, curr+1, ans)
                nums[i], nums[curr] = nums[curr], nums[i]
        
        ans = []
        dfs(nums, 0 ,ans)
        return ans
```

法二


```
class Solution(object):
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        ans = []
        def dfs(nums,path,ans):
            if not nums:
                ans.append(path)
            else:
                for i in range(len(nums)):
                    dfs(nums[:i]+nums[i+1:],path+[nums[i]],ans)
        dfs(nums,[],ans)
        return ans
```
note：
1. 这里并没有显式的回溯过程，原因是，递归传入的就是去掉i项后的nums，并不影响下一轮循环中的nums，所以不必显式写出回溯过程

### Permutations II

leetcode第47题，全排列的升级版，要求需要全排列的数组中有重复，输出去重后的结果。

这个题可以充分运用语言上的特点，比如先生成带有重复项的全排列，这在之前那道题目已经完成了，然后set一下去重，但是这样做太不自然了，复杂度肯定也会依赖于set去重操作，有没有自然去掉重复项的办法呢？

可以这样考虑，为什么会产生重复项，因为数组中含有重复数字。在每一轮深搜的时候，单独设置一个dict记录用到的数字，如果在碰到相同的数字出现，就会在字典里查出来，这就意味着这个数字不用再进行下一步dfs了，因为已经有一个和它完全相同的数字已经搜索了，这样就自然去重了。

```
class Solution(object):
    def permuteUnique(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """

        ans = []
        def dfs(nums, ans, path):
            if not nums:
                ans.append(path)
            else:
                d = {}  # 每一步递归都要建一个dict用来去重
                for i in xrange(len(nums)):
                    if nums[i] not in d:
                        dfs(nums[:i]+nums[i+1:], ans, path+[nums[i]])
                        d[nums[i]] = 1
        nums.sort()
        dfs(nums, ans, [])
        return ans
```

### Next Permutation

leetcode第31题，要求给定一组数字，输出字典序下下一个全排列，要求原地修改。

首先，要求原地修改，就不要想着先生成在去查找这个办法了。其实这个方法比较难想出来，主要是找按字典序排列的相邻的全排列之间有什么规律。

从最后一位向前搜索，如果一直处于递减状态，说明这一段全排列没法动，因为这一个子段已经处于字典序的最大值了，无论怎么换，都不可能增大这一段的字典序。直到发现搜索到某个位置，递减被打断，说明这个地方还没有满足全排列的最大值，可以做手脚了。于是我们从这个截断点反向搜索一个只比他小一点的数，交换其位置。最后一步，由于这个子段已经处于全排的最大字典序，因此就如同加法进位一样，自动回转到字典序最小值，也就是逆序一下就可以了。

```
class Solution(object):
    def nextPermutation(self, nums):
        """
        :type nums: List[int]
        :rtype: void Do not return anything, modify nums in-place instead.
        """
        def swap(nums,i1,i2):
            tmp = nums[i1]
            nums[i1] = nums[i2]
            nums[i2] = tmp

        def reverse(nums, start, end):
            while start < end:
                swap(nums, start, end)
                start += 1
                end -= 1

        n = len(nums)
        i = n-2
        while i >= 0 and nums[i+1] <= nums[i]:  # 从后向前，找出递增序列打断的地方
            i -= 1
        if i >= 0:
            j = n-1
            while j >= 0 and nums[j] <= nums[i]: # 从后向前，找一个比i大，但是在后面序列中最小的数字
                j -= 1
            swap(nums, i, j)
        reverse(nums, i+1, n-1) # 从i后一格到最后翻转
```


### Permutation Sequence

比较好的方法是使用康托展开，关于这一部分我参见了这个blog http://blog.csdn.net/synapse7/article/details/16901489


排列的编码

> {1,2,3,4,...,n}的排列总共有n!种，将它们从小到大排序，怎样知道其中一种排列是有序序列中的第几个？

如 {1,2,3} 按从小到大排列一共6个：123 132 213 231 312 321。想知道321是{1,2,3}中第几个大的数。

这样考虑：第一位是3，小于3的数有1、2 。所以有2*2!个。再看小于第二位，小于2的数只有一个就是1 ，所以有1*1!=1 所以小于32

的{1,2,3}排列数有2*2!+1*1!=5个。所以321是第6个大的数。2*2!+1*1!是康托展开。（注意判断排列是第几个时要在康托展开的结果后+1）

再举个例子：1324是{1,2,3,4}排列数中第几个大的数：第一位是1小于1的数没有，是0个，0*3!，第二位是3小于3的数有1和2，但1已经在第一位了，所以只有一个数2，1*2! 。第三位是2小于2的数是1，但1在第一位，所以有0个数，0*1!，所以比1324小的排列有0*3!+1*2!+0*1!=2个，1324是第三个大数。

又例如，排列3 5 7 4 1 2 9 6 8展开为98884，因为X=2*8!+3*7!+4*6!+2*5!+0*4!+0*3!+2*2!+0*1!+0*0!=98884.
解释：
排列的第一位是3，比3小的数有两个，以这样的数开始的排列有8!个，因此第一项为2*8!

排列的第二位是5，比5小的数有1、2、3、4，由于3已经出现，因此共有3个比5小的数，这样的排列有7!个，因此第二项为3*7!
以此类推，直至0*0!


一句话总结，外循环遍历每个位置，内循环在这个位置之后找出比这个位置的数字更小的数，并计数，乘以对应的阶乘数，累加即可。

    #include<cstdio>
    const int fac[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320};///阶乘
     
    int KT(int s[], int n)
    {
        int i, j, cnt, sum;
        sum = 0;
        for (i = 0; i < n; ++i)
        {
            cnt = 0;
            for (j = i + 1; j < n; ++j)
                if (s[j] < s[i]) ++cnt;
            sum += cnt * fac[n - i - 1]; # 这里要减去一个1, 比如一共4位数，第一位是3的阶乘
        }
        return sum;
    }
     
    int main()
    {
        int a[] = {3, 5, 7, 4, 1, 2, 9, 6, 8};
        printf("%d\n", 1 + KT(a, sizeof(a) / sizeof(*a))); ///1+98884
    }

序列的解码

如何找出第16个（按字典序的）{1,2,3,4,5}的全排列？

1. 首先用16-1得到15

2. 用15去除4! 得到0余15

3. 用15去除3! 得到2余3

4. 用3去除2! 得到1余1

5. 用1去除1! 得到1余0

有0个数比它小的数是1，所以第一位是1

有2个数比它小的数是3，但1已经在之前出现过了所以是4

有1个数比它小的数是2，但1已经在之前出现过了所以是3

有1个数比它小的数是2，但1,3,4都出现过了所以是5

最后一个数只能是2

所以排列为1 4 3 5 

    def getPermutation3(n, k):
        import math
        factor = [math.factorial(i) for i in range(0, n + 1)]
        print factor
        visit = [False] * (n+1)

        ans = ""
        k -= 1  # 第k个在代码中就是第15号元素，从0开始计数
    
        for i in range(1, n+1): #从1到n遍历
            tmp = k/factor[n-i]
            for j in range(1, n+1): # 从1到n检查有没有用过的数字
                if visit[j] == False:
                    if tmp == 0:
                        break
                    tmp -= 1
            visit[j] = True
            ans += str(j)
            k %= factor[n-i]
        return ans


### Combination Sum

leetcode第39题，回溯题，要求用给定集合中的数字使得相加等于目标数字，其中给定集合中的数字可以无限次使用。

注意，这里题目要求所有数字都是正数，这就保证了递归的出口条件。

分析问题，首先，递归的出口条件有两个，一个是相加出现了目标和，那么就加入了结果列表，返回。另外，由于给定集合都是正数，所以相加如果超过了目标和，就要立即返回。然后遍历集合，不断向下递归搜索。

还有一个比较关键的问题，就是如何去重。这里我们先把目标集合排一下序，然后在递归搜索的时候先判断要加入的数字和之前列表中最后一个数字的大小关系，这样就确保了我们搜索出来的结果一定是一个递增的关系，这样就会不会重复了。

    class Solution(object):
        def combinationSum(self, candidates, target):
            """
            :type candidates: List[int]
            :type target: int
            :rtype: List[List[int]]
            """
            n = len(candidates)
            candidates.sort()
            ans = []

            def dfs(tryList):
                if sum(tryList) == target:
                    ans.append(tryList)
                    return
                if sum(tryList) > target:
                    return
                for i in range(n):
                    if len(tryList) != 0 and  candidates[i] < tryList[-1]:  # 要加入的候选数字与trylist的末尾比较
                        continue
                    dfs(tryList+[candidates[i]])

            dfs([])
            return ans


### Combination Sum II

leetcode第40题，要求在候选数组中选出一组数字求和等于目标数，与前一题不同的是，这次每个数字只能选择一次。

首先要明白每个数字只能选一次，一开始想用一个数组记录一下每个数是否被用过，但是很快发现这个数组如果是全局的完全没有效果，于是就引入了深拷贝，确保每个递归函数拿到的都是其副本而不是视图，但是这样做大数据跑不过去。

其实按照dfs的思路，去重并不是很麻烦的一件事，完全不需要申请额外内存，因为只要记录一下每次从什么位置开始深搜，这样就不会重复，不过这里有一个小陷阱，那就是候选数组中会有重复的数字，这样也会造成重复。解决办法是，dfs之前先对数组排序，dfs的时候判断一下前后两个数字是不是一样的，如果一样就跳过，避免重复结果出现。

```
class Solution(object):
    def combinationSum2(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        import copy
        ans = []
        candidates.sort()

        def dfs(tryList, start):
            if sum(tryList) == target:
                ans.append(tryList)
                return
            elif sum(tryList) > target:
                return

            for i in range(start, len(candidates)):
                if i != start and candidates[i] == candidates[i - 1]: # i防止越界
                    continue
                dfs(tryList+[candidates[i]], i+1)

        dfs([], 0)
        return ans
```

note：
去重的主要方法是，在本层递归跳过那些重复的数字，可以用字典距离，也可以排序后找前后关系

### Combinations

leetcode第77题，排列组合题升级版，这个题的总体难度不太大，但是鉴于使用的是python，如果不剪枝，就一定会超时。

首先分析问题，先要按顺序挑选出开头的元素，此时所给集合中的所有元素均可以添加，然后把加上了开头元素的列表向下递归，添加第二个元素，第二个元素的要求应该是第一个元素之后的所有元素均可，同时记录递归层级的变量level自增。递归的出口条件是，当level达到了指定的个数后，数名数字添加完毕，则可以加入最终的结果列表中。

如果单纯这样写结果正确，但是大数据会TLE，于是参考别人的剪枝方法，那就是在递归添加元素的过程中，如果发现所剩的元素根本不够，即使全部用掉也凑不够k个，这样的循环就可以提前终止了。这个剪枝卡了我很久，不加这个就会超时。

    class Solution(object):
        def combine(self, n, k):
            """
            :type n: int
            :type k: int
            :rtype: List[List[int]]
            """
            ans = []
            def dfs(subList,start,level):
                if level == k:
                    ans.append(subList)
                    return
                for i in xrange(start,n+1):
                    if n-i < k-level-1 :break  # 一共n个元素，目前只用了i-1个元素,这句话出现还没有添加第i个元素。 一共需要凑k个元素，当前凑到了第level个元素 n-(i-1) < k-level
                    dfs(subList+[i],i+1,level+1)
            dfs([],1,0)
            return ans


### Subsets

leetcode第78题，寻找给定集合的所有子集，包括空集。

一开始准备使用深搜，这也做倒也没啥问题，但是去重是一个很麻烦的事情。换种思路决定用二进制来做。

将给定集合的每个元素分别用一个二进制位代表，1表示该元素在子集合中，0表示不在子集中。这样所有二进制数的情况就对应了所有子集的可能情况，只要一一对应出来即可。

注意python的bin函数是转换二进制数，但是前面带着一个0b字符，所以我们要对它做一些处理，还要对齐数位，形成一个标准的字符串。

    class Solution(object):
        def subsets(self, nums):
            """
            :type nums: List[int]
            :rtype: List[List[int]]
            """
            n = len(nums)
            binNum = 2**n
            ans = []
            for i in range(binNum):
                s = "0"*(n-len(str(bin(i))[2:]))+str(bin(i))[2:]
                print s
                subAns = []
                for j in range(n):
                    if s[j] == '1':
                        subAns.append(nums[j])
                ans.append(subAns)
            return ans
最近又学习了另外一种思路，回溯法，主要是用到了dfs，基本思路是，数组排序之后，每次按顺序向path中加入一个数字，加入后用dfs扩展后一位，每次进入递归函数时都要保存到最终结果数组中，当扩展到最后一位时，函数返回到上一层，上一层函数把最后一位删去，再引进下一位。

    class Solution:
        def subsets(self, nums):
            """
            :type nums: List[int]
            :rtype: List[List[int]]
            """
            n = len(nums)
            nums.sort()
            def dfs(nums,pos, path, ans):
                import copy
                ans.append(copy.deepcopy(path))
                for i in range(pos,len(nums)):
                    path.append(nums[i])
                    dfs(nums, i+1, path, ans)
                    path.pop()
            ans = []
            dfs(nums, 0, [], ans)
            return ans

### Subsets II

```
class Solution:
    def subsetsWithDup(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        
        self.ans = []
        
        def dfs(nums, pos, path):
            
            self.ans.append(copy.deepcopy(path))
            
            d = {}
            for i in range(pos, len(nums)):
                
                if nums[i] not in d:
                
                    dfs(nums, i+1, path+[nums[i]])
                    
                    d[nums[i]] = 1
        
        nums.sort()
        dfs(nums, 0, [])
        return self.ans  
```
note：
1. 使用字典记录重复的值，达到去重的目的
2. 先要对序列排序是很关键的一步，只有这样才可以保证从i向后搜索不会搜到相同的数字

### word search

leetcode 第79题，图上的深搜题。
第一步，先要写个遍历循环，找到搜索的起点，也就是首字母。
第二步，从起点出发开始搜索，搜索时主要要记录已经走过的地方，这里可以使用一个二维的数组单独来记录，或者走过的地方标识为‘#’，搜索后恢复这个位置的字符。
注意，每次搜索时，都要比较word和当前路径已经遍历到的字符，这里可以使用增量式的比较方法，每次比较一个字符即可。

```
class Solution:
    def exist(self, board, word):
        """
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """
        row = len(board)
        col = len(board[0])
        
        def dfs(current_x, current_y, board, index, word):
            
            if index == len(word)-1:
                return True

            tmp = board[current_x][current_y]
            board[current_x][current_y] = '#'

            if current_x+1 < row and board[current_x+1][current_y] == word[index+1]:
                if dfs(current_x+1, current_y, board, index+1, word):
                    return True
            if current_x-1 >= 0 and board[current_x-1][current_y] == word[index+1]:
                if dfs(current_x-1, current_y, board, index+1, word):
                    return True
            if current_y+1 < col and board[current_x][current_y+1] == word[index+1]:
                if dfs(current_x, current_y+1, board, index+1, word):
                    return True 
            if current_y-1 >= 0 and board[current_x][current_y-1] == word[index+1]:
                if dfs(current_x, current_y-1, board, index+1, word):
                    return True

            board[current_x][current_y] = tmp
            
            return False
                
        for i in range(row):
            for j in range(col):
                if board[i][j] == word[0]:
                    if dfs(i, j, board, 0, word):
                        return True
        return False
                    
```

### Restore IP Addresses

leetcode第93题，计算有效的IP地址。

分析问题，首先什么是有效的IP，这里有效是广义的，也就是凡是符合IP的要求的都算，不考虑特殊IP地址的限制。这样有效IP的要求就放宽了不少，首先IP应该有四级，每一个的数字都应该在0-255之间，还有一点比较隐蔽，那就是0单独出现时正确的，但是如“”010”这样的数字就是不合法的了。

确认有效IP的格式后，就要分析算法，这里运用深度搜索，递归出口条件有两个，一个是长度上不符合要求则要立刻返回，而是当递归到最后一层时需要判断首位是否为0且在0-255范围内。

递归的时候，遍历方式为从当前第一个字符开始依次向后扩展1-3个字符。

    class Solution(object):
        def restoreIpAddresses(self, s):
            """
            :type s: str
            :rtype: List[str]
            """
            def dfs(string,n):
                if len(string) > 3*n or len(string) < n: # 如果长度不符合要求则直接返回
                    return []
                if n == 1: # 考虑处理到最后的字符串的情况
                    if string[0] == '0' and len(string) > 1: # 开头是0，但不是单个的0返回
                        return []
                    if int(string) > 255: # 最后的子串超出范围返回
                        return []
                    return [string]
        
                ret = []
                for i in xrange(1,4):
                    if string[0] == '0' and i > 1: # 开头是0，不是单个的0
                        continue
                    if int(string[:i]) > 255: # 超出返回
                        continue
                    iret = dfs(string[i:],n-1) # 深搜
                    if len(iret) > 0:
                        ret += [string[:i]+'.'+iiret for iiret in iret]
                return ret
        
            return dfs(s,4)

### Unique Binary Search Trees II


    # Definition for a binary tree node.
    # class TreeNode:
    #     def __init__(self, x):
    #         self.val = x
    #         self.left = None
    #         self.right = None

    class Solution(object):
        def generateTrees(self, n):
            if n == 0:
                return []
            return self.helper(1, n)

        def helper(self, start, end):
            result = []
            if start > end:  # 出口条件是 start比end大了，此时子树为空，但还要以list形式返回
                result.append(None)
                return result

            for i in range(start, end + 1):  # 从start到end，依次以i为root node

                # generate left and right sub tree
                leftTree = self.helper(start, i - 1)    # 返回的是左右子树list
                rightTree = self.helper(i + 1, end)

                # link left and right sub tree to root(i)
                for j in range(len(leftTree)):    # 分别加挂左右子树
                    for k in range(len(rightTree)):
                        root = TreeNode(i)
                        root.left = leftTree[j]
                        root.right = rightTree[k]
                        result.append(root)  # result收集本层生成的subtree，向上提交，帮助上一层构建树

            return result
note：
1. 遍历所有可能的node值，选取一个作为root节点
2. 小于root的可以作为左子树，大于root的可以作为右子树
3. 左子树和右子树同样也会生成不同的形态。

### Path Sum

    class Solution:
        
        def __init__(self):
            self.ans = False
        
        def hasPathSum(self, root, sum):
            """
            :type root: TreeNode
            :type sum: int
            :rtype: bool
            """
            
            def dfsTopDown(node, sumNum, sum):
                
                sumNum += node.val
                
                if node.left == None and node.right == None:
                    if sumNum == sum:
                        self.ans = True
                    return
                
                if node.left != None:
                    dfsTopDown(node.left, sumNum, sum)
                if node.right != None:
                    dfsTopDown(node.right, sumNum, sum)
            
            if root == None:
                return False
            dfsTopDown(root, 0, sum)
            return self.ans
note:
这里有个基本问题，就是什么时候使用回溯，什么时候不使用。比如在下面的题目中，path就要回溯，因为先执行left上的搜索，如果搜索没有完成，path此时已经把left的节点加进来了，于是应该先行pop掉left的node，才能执行right上的搜索。反之，sumNum则不需要没因为在本层递归，sumnum并没有变化，所以无须回溯。


### Path Sum II

https://leetcode.com/problems/path-sum-ii/description/

    # Definition for a binary tree node.
    # class TreeNode(object):
    #     def __init__(self, x):
    #         self.val = x
    #         self.left = None
    #         self.right = None

    class Solution:
        def pathSum(self, root, sum):
            """
            :type root: TreeNode
            :type sum: int
            :rtype: List[List[int]]
            """
            
            import copy
            def dfs(node, path, tmpSum, ans):
                
                # if node == None:
                    # return
                
                path.append(node.val)
                tmpSum += node.val
                
                if node.left == None and node.right == None:
                    if tmpSum == sum:
                        ans.append(copy.deepcopy(path))
                
                if node. left:
                    dfs(node.left, path, tmpSum, ans)
                
                if node.right:
                    dfs(node.right, path, tmpSum, ans)
                    
                path.pop()  # 回溯
                
            ans = []
            dfs(root, [], 0, ans)
            return ans

### Number of Island'


法一：并查集

    class Solution(object):
        def numIslands(self, grid):
            """
            :type grid: List[List[str]]
            :rtype: int
            """
            row = len(grid)
            if row == 0:
                return 0
            col = len(grid[0])
            self.count = sum(grid[i][j]=='1' for i in range(row) for j in range(col))
            parent = [i for i in range(row*col)]
            def find(x):
                if parent[x] != x:
                    return find(parent[x])
                return parent[x]
            def union(x,y):
                a = find(x)
                b = find(y)
                if a == b:
                    return
                parent[a] = b
                self.count -= 1
            for i in range(row):
                for j in range(col):
                    if grid[i][j] == '0':continue
                    index = i*col+j
                    if j < col-1 and grid[i][j+1] == '1':
                        union(index,index+1)
                    if i < row-1 and grid[i+1][j] == '1':
                        union(index,index+col)
            return self.count

法二：深搜


    class Solution(object):
        def numIslands(self, grid):
            """
            :type grid: List[List[str]]
            :rtype: int
            """
            
            row = len(grid)  # 处理边界
            if row == 0:
                return 0
            col = len(grid[0])
            if col == 0:
                return 0
            
            
            res  = 0
            visit = [[0] * col for i in range(row)]
            
            def dfs(grid, visit, i, j):
                
                if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):  # 边界条件
                    return
                
                if grid[i][j] == "0" or visit[i][j] == 1:   # 已经被踩中的和0的直接返回
                    return
                
                visit[i][j] = 1   # 标记已经走过的点
                
                dfs(grid, visit, i+1, j)   # 四个方向dfs
                dfs(grid, visit, i-1, j)
                dfs(grid, visit, i, j-1)
                dfs(grid, visit, i, j+1)  # 不需要回溯
                
            for i in range(row):
                for j in range(col):
                    if grid[i][j] == "1" and visit[i][j] == 0:
                        dfs(grid, visit, i, j)
                        res += 1
            
            return res

note：
1. 遍历整个网格，寻找合适的起始点，一旦dfs走完了，说明有一大块相邻的都被标记visit过了，因此res+1，重新寻找起始点。这样走完多少次，就应该有多少块
