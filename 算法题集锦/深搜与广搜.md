
## DFS 和 BFS


### Permutations

注意，题目数组中无重复元素。

法一

全排列这个问题很明显是回溯，但是怎么找状态空间是个问题。假设1234是初始的四个数字，如何产生全排列呢？可以把第一个数字1依次与之后的数字交换，会产生一组数字分别为1234、2134、3214、4321。注意，假设1与2交换，变为2134，这又是一个新的数字，可以在此基础上再次进行上述操作，不过这回是从第二个数字开始依次与后面的数字交换，因为再从第一个开始就会又出现1234了，这样2134又会出现2134、2314、2341.如此下去，每个数字都可以这样进行操作。递归的出口就是当进行到最后一个数字时，由于没有后面数字可以交换了，前面的数字交换情况也都有了，于是可以返回。


	class Solution:
	    def permute(self, nums):
	        """
	        :type nums: List[int]
	        :rtype: List[List[int]]
	        """
	        import copy
	        def dfs(nums, curr, ans):
	            if curr == len(nums) - 1:
	                ans.append(copy.deepcopy(nums))
	                return
	            
	            for i in range(curr, len(nums)):
	                nums[i], nums[curr] = nums[curr], nums[i]
	                dfs(nums, curr+1, ans)
	                nums[i], nums[curr] = nums[curr], nums[i]
	        
	        ans = []
	        dfs(nums, 0 ,ans)
	        return ans

法二


	class Solution(object):
	    def permute(self, nums):
	        """
	        :type nums: List[int]
	        :rtype: List[List[int]]
	        """
	        ans = []
	        def dfs(nums,path,ans):
	            if not nums:
	                ans.append(path)
	            else:
	                for i in range(len(nums)):
	                    dfs(nums[:i]+nums[i+1:],path+[nums[i]],ans)
	        dfs(nums,[],ans)
	        return ans

note：
1. 这里并没有显式的回溯过程，原因是，递归传入的就是去掉i项后的nums，并不影响下一轮循环中的nums，所以不必显式写出回溯过程

### Permutations II

leetcode第47题，全排列的升级版，要求需要全排列的数组中有重复，输出去重后的结果。

这个题可以充分运用语言上的特点，比如先生成带有重复项的全排列，这在之前那道题目已经完成了，然后set一下去重，但是这样做太不自然了，复杂度肯定也会依赖于set去重操作，有没有自然去掉重复项的办法呢？

可以这样考虑，为什么会产生重复项，因为数组中含有重复数字。在每一轮深搜的时候，单独设置一个dict记录用到的数字，如果在碰到相同的数字出现，就会在字典里查出来，这就意味着这个数字不用再进行下一步dfs了，因为已经有一个和它完全相同的数字已经搜索了，这样就自然去重了。


	class Solution(object):
	    def permuteUnique(self, nums):
	        """
	        :type nums: List[int]
	        :rtype: List[List[int]]
	        """
	
	        ans = []
	        def dfs(nums, ans, path):
	            if not nums:
	                ans.append(path)
	            else:
	                d = {}  # 每一步递归都要建一个dict用来去重
	                for i in xrange(len(nums)):
	                    if nums[i] not in d:
	                        dfs(nums[:i]+nums[i+1:], ans, path+[nums[i]])
	                        d[nums[i]] = 1
	        nums.sort()
	        dfs(nums, ans, [])
	        return ans


### Next Permutation

leetcode第31题，要求给定一组数字，输出字典序下下一个全排列，要求原地修改。

首先，要求原地修改，就不要想着先生成在去查找这个办法了。其实这个方法比较难想出来，主要是找按字典序排列的相邻的全排列之间有什么规律。

从最后一位向前搜索，如果一直处于递减状态，说明这一段全排列没法动，因为这一个子段已经处于字典序的最大值了，无论怎么换，都不可能增大这一段的字典序。直到发现搜索到某个位置，递减被打断，说明这个地方还没有满足全排列的最大值，可以做手脚了。于是我们从这个截断点反向搜索一个只比他小一点的数，交换其位置。最后一步，由于这个子段已经处于全排的最大字典序，因此就如同加法进位一样，自动回转到字典序最小值，也就是逆序一下就可以了。


	class Solution(object):
	    def nextPermutation(self, nums):
	        """
	        :type nums: List[int]
	        :rtype: void Do not return anything, modify nums in-place instead.
	        """
	        def swap(nums,i1,i2):
	            tmp = nums[i1]
	            nums[i1] = nums[i2]
	            nums[i2] = tmp
	
	        def reverse(nums, start, end):
	            while start < end:
	                swap(nums, start, end)
	                start += 1
	                end -= 1
	
	        n = len(nums)
	        i = n-2
	        while i >= 0 and nums[i+1] <= nums[i]:  # 从后向前，找出递增序列打断的地方
	            i -= 1
	        if i >= 0:
	            j = n-1
	            while j >= 0 and nums[j] <= nums[i]: # 从后向前，找一个比i大，但是在后面序列中最小的数字
	                j -= 1
	            swap(nums, i, j)
	        reverse(nums, i+1, n-1) # 从i后一格到最后翻转



### Permutation Sequence

比较好的方法是使用康托展开，关于这一部分我参见了这个blog [http://blog.csdn.net/synapse7/article/details/16901489](http://blog.csdn.net/synapse7/article/details/16901489)

排列的编码

> {1,2,3,4,...,n}的排列总共有n!种，将它们从小到大排序，怎样知道其中一种排列是有序序列中的第几个？

如 {1,2,3} 按从小到大排列一共6个：123 132 213 231 312 321。想知道321是{1,2,3}中第几个大的数。

这样考虑：第一位是3，小于3的数有1、2,也就是说第一位只能有两种选择，所以在321前面有2*2!个排列。此时固定最高位为3，再看第二位，小于第二位，2的数只有一个就是1 ，所以有1*1!=1 所以小于321
的{1,2,3}排列数有2*2!+1*1!=5个。所以321是第6个大的数。2*2!+1*1!是康托展开。（注意判断排列是第几个时要在康托展开的结果后+1）

再举个例子：1324是{1,2,3,4}排列数中第几个大的数：第一位是1小于1的数没有，是0个，0*3!，第二位是3小于3的数有1和2，但1已经在第一位了，所以只有一个数2，1*2! 。第三位是2小于2的数是1，但1在第一位，所以有0个数，0*1!，所以比1324小的排列有0*3!+1*2!+0*1!=2个，1324是第三个大数。

又例如，排列3 5 7 4 1 2 9 6 8展开为98884，因为X=2*8!+3*7!+4*6!+2*5!+0*4!+0*3!+2*2!+0*1!+0*0!=98884.
解释：
排列的第一位是3，比3小的数有两个，以这样的数开始的排列有8!个，因此第一项为2*8!

排列的第二位是5，比5小的数有1、2、3、4，由于3已经出现，因此共有3个比5小的数，这样的排列有7!个，因此第二项为3*7!
以此类推，直至0*0!


一句话总结，外循环遍历每个位置，内循环在这个位置之后找出比这个位置的数字更小的数，并计数，乘以对应的阶乘数，累加即可。

    #include<cstdio>
    const int fac[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320};///阶乘
     
    int KT(int s[], int n)
    {
        int i, j, cnt, sum;
        sum = 0;
        for (i = 0; i < n; ++i)
        {
            cnt = 0;
            for (j = i + 1; j < n; ++j)
                if (s[j] < s[i]) ++cnt;
            sum += cnt * fac[n - i - 1]; # 这里要减去一个1, 比如一共4位数，第一位是3的阶乘
        }
        return sum;
    }
     
    int main()
    {
        int a[] = {3, 5, 7, 4, 1, 2, 9, 6, 8};
        printf("%d\n", 1 + KT(a, sizeof(a) / sizeof(*a))); ///1+98884
    }

序列的解码

如何找出第16个（按字典序的）{1,2,3,4,5}的全排列？

1. 首先用16-1得到15

2. 用15去除4! 得到0余15

3. 用15去除3! 得到2余3

4. 用3去除2! 得到1余1

5. 用1去除1! 得到1余0

有0个数比它小的数是1，所以第一位是1

有2个数比它小的数是3，但1已经在之前出现过了所以是4

有1个数比它小的数是2，但1已经在之前出现过了所以是3

有1个数比它小的数是2，但1,3,4都出现过了所以是5

最后一个数只能是2

所以排列为1 4 3 5 

    def getPermutation3(n, k):
        import math
        factor = [math.factorial(i) for i in range(0, n + 1)]
        print factor
        visit = [False] * (n+1)

        ans = ""
        k -= 1  # 第k个在代码中就是第15号元素，从0开始计数
    
        for i in range(1, n+1): #从1到n遍历
            tmp = k/factor[n-i]
            for j in range(1, n+1): # 从1到n检查有没有用过的数字
                if visit[j] == False:
                    if tmp == 0:
                        break
                    tmp -= 1
            visit[j] = True
            ans += str(j)
            k %= factor[n-i]
        return ans


### Combination Sum

leetcode第39题，回溯题，要求用给定集合中的数字使得相加等于目标数字，其中给定集合中的数字可以无限次使用。

- 注意，数组中并没有重复数字。
- 注意，题目要求所有数字都是正数，这就保证了递归的出口条件。

分析问题，首先，递归的出口条件有两个，一个是相加出现了目标和，那么就加入了结果列表，返回。另外，由于给定集合都是正数，所以相加如果超过了目标和，就要立即返回。然后遍历集合，不断向下递归搜索。

还有一个比较关键的问题，就是如何去重。这里我们先把目标集合排一下序，然后在递归搜索的时候先判断要加入的数字和之前列表中最后一个数字的大小关系，这样就确保了我们搜索出来的结果一定是一个递增（不减序列，因为是<就跳过）的关系，这样就会不会重复了。

    class Solution(object):
        def combinationSum(self, candidates, target):
            """
            :type candidates: List[int]
            :type target: int
            :rtype: List[List[int]]
            """
            n = len(candidates)
            candidates.sort()
            ans = []

            def dfs(tryList):
                if sum(tryList) == target:
                    ans.append(tryList)
                    return
                if sum(tryList) > target:
                    return
                for i in range(n):
                    if len(tryList) != 0 and  candidates[i] < tryList[-1]:  # 要加入的候选数字与trylist的末尾比较
                        continue
                    dfs(tryList+[candidates[i]])

            dfs([])
            return ans
新版本：

	class Solution:
    def combinationSum(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        
        def dfs(curSum, curList, ans):
            
            if curSum > target:
                return
            if curSum == target:
                ans.append(curList)
            
            for num in candidates:
                if len(curList)!= 0 and num < curList[-1]:
                    continue
                dfs(curSum+num, curList+[num], ans)
        
        ans = []
        candidates.sort()
        dfs(0, [], ans)
        return ans


### Combination Sum II

leetcode第40题，要求在候选数组中选出一组数字求和等于目标数，与前一题不同的是，这次每个数字只能选择一次。

首先要明白每个数字只能选一次，一开始想用一个数组记录一下每个数是否被用过，但是很快发现这个数组如果是全局的完全没有效果，于是就引入了深拷贝，确保每个递归函数拿到的都是其副本而不是视图，但是这样做大数据跑不过去。

其实按照dfs的思路，去重并不是很麻烦的一件事，完全不需要申请额外内存，因为只要记录一下每次从什么位置开始深搜，这样就不会重复，不过这里有一个小陷阱，那就是候选数组中会有重复的数字，这样也会造成重复。解决办法是，dfs之前先对数组排序，dfs的时候判断一下前后两个数字是不是一样的，如果一样就跳过，避免重复结果出现。

	class Solution(object):
	    def combinationSum2(self, candidates, target):
	        """
	        :type candidates: List[int]
	        :type target: int
	        :rtype: List[List[int]]
	        """
	        import copy
	        ans = []
	        candidates.sort()
	
	        def dfs(tryList, start):  # start这里指下一个递归搜索的起始位置
	            if sum(tryList) == target:
	                ans.append(tryList)
	                return
	            elif sum(tryList) > target:
	                return
	
	            for i in range(start, len(candidates)):
	                if i != start and candidates[i] == candidates[i - 1]: # i防止越界，同时去重
	                    continue
	                dfs(tryList+[candidates[i]], i+1) # 从i+1开始下一层搜索，避免了在i+1前面搜索，这样可以防止顺序重复
	
	        dfs([], 0)
	        return ans


note：
去重的主要方法是，在本层递归跳过那些重复的数字，可以用字典距离，也可以排序后找前后关系


### Combination Sum III

[https://leetcode.com/problems/combination-sum-iii/description/](https://leetcode.com/problems/combination-sum-iii/description/)

	class Solution:
	    def combinationSum3(self, k, n):
	        """
	        :type k: int
	        :type n: int
	        :rtype: List[List[int]]
	        """
	        nums = [i for i in range(1, 10)]
	        print(nums)
	        
	        def dfs(curSum, curList, startIndex, ans):
	            
	            if curSum == n and len(curList) == k:
	                ans.append(curList)
	            
	            if curSum > n:
	                return
	            
	            for i in range(startIndex, len(nums)):
	                num = nums[i]
	                dfs(curSum+num, curList+[num], i+1, ans) # 注意这里一定是i+1，不是startIndex+1，加入nums[i]后从从i的后一位开始下一轮搜索
	        
	        ans = []
	        dfs(0, [], 0, ans)
	        return ans
       
note：

1. 候选数组中不存在重复，因此不需要单独的去重措施。
2. 每个数字只能选一次，所有dfs的时候要记录下一次搜索的起始位置，起始位置之前的就不需要搜索了。


### Combination Sum IV

[https://leetcode.com/problems/combination-sum-iv/description/](https://leetcode.com/problems/combination-sum-iv/description/)

	class Solution:
	    def combinationSum4(self, nums, target):
	        """
	        :type nums: List[int]
	        :type target: int
	        :rtype: int
	        """
	        
	        dp = [0] * (target+1)
	        dp[0] = 1
	        
	        for i in range(1, target+1): # 从1开始到target结束
	            for num in nums:
	                if num <= i:
	                    dp[i] += dp[i-num]
	        
	        return dp[-1]
	
note：

1. 这次是要求加和为目标数的种类数，因此可以不搜索，直接使用dp。
2. dp[i]代表了凑成i有多少种方案。 
3. dp[0]初始化为1，代表了凑成i只有一种方案，就是什么也不取。
4. 转移方程的意思是，dp[i-num]加上num就可以凑成i了，那么dp[i]的方案数就可以由dp[i-num]继承过来。

### Combinations

leetcode第77题，排列组合题升级版，这个题的总体难度不太大，但是鉴于使用的是python，如果不剪枝，就会超时。

首先分析问题，先要按顺序挑选出开头的元素，此时所给集合中的所有元素均可以添加，然后把加上了开头元素的列表向下递归，添加第二个元素，第二个元素的要求应该是第一个元素之后的所有元素均可，同时记录递归层级的变量level自增。递归的出口条件是，当level达到了指定的个数后，数名数字添加完毕，则可以加入最终的结果列表中。

如果单纯这样写结果正确，但是大数据会TLE，于是参考别人的剪枝方法，那就是在递归添加元素的过程中，如果发现所剩的元素根本不够，即使全部用掉也凑不够k个，这样的循环就可以提前终止了。这个剪枝卡了我很久，不加这个就会超时。

    class Solution(object):
        def combine(self, n, k):
            """
            :type n: int
            :type k: int
            :rtype: List[List[int]]
            """
            ans = []
            def dfs(subList,start,level):
                if level == k:
                    ans.append(subList)
                    return
                for i in xrange(start,n+1):
                    if n-i < k-level-1 :break  # 一共n个元素，目前只用了i-1个元素,这句话出现还没有添加第i个元素。 一共需要凑k个元素，当前凑到了第level个元素 n-(i-1) < k-level
                    dfs(subList+[i],i+1,level+1)
            dfs([],1,0)
            return ans


### Subsets

leetcode第78题，寻找给定集合的所有子集，包括空集。

一开始准备使用深搜，这也做倒也没啥问题，但是去重是一个很麻烦的事情。换种思路决定用二进制来做。

将给定集合的每个元素分别用一个二进制位代表，1表示该元素在子集合中，0表示不在子集中。这样所有二进制数的情况就对应了所有子集的可能情况，只要一一对应出来即可。

注意python的bin函数是转换二进制数，但是前面带着一个0b字符，所以我们要对它做一些处理，还要对齐数位，形成一个标准的字符串。

    class Solution(object):
        def subsets(self, nums):
            """
            :type nums: List[int]
            :rtype: List[List[int]]
            """
            n = len(nums)
            binNum = 2**n
            ans = []
            for i in range(binNum):
                s = "0"*(n-len(str(bin(i))[2:]))+str(bin(i))[2:]
                print s
                subAns = []
                for j in range(n):
                    if s[j] == '1':
                        subAns.append(nums[j])
                ans.append(subAns)
            return ans

最近又学习了另外一种思路，回溯法，主要是用到了dfs，基本思路是，数组排序之后，每次按顺序向path中加入一个数字，加入后用dfs扩展后一位，每次进入递归函数时都要保存到最终结果数组中，当扩展到最后一位时，函数返回到上一层，上一层函数把最后一位删去，再引进下一位。

    class Solution:
        def subsets(self, nums):
            """
            :type nums: List[int]
            :rtype: List[List[int]]
            """
            n = len(nums)
            nums.sort()
            def dfs(nums,pos, path, ans):
                import copy
                ans.append(copy.deepcopy(path))
                for i in range(pos,len(nums)):
                    path.append(nums[i])
                    dfs(nums, i+1, path, ans)
                    path.pop()
            ans = []
            dfs(nums, 0, [], ans)
            return ans

### Subsets II


	class Solution:
	    def subsetsWithDup(self, nums):
	        """
	        :type nums: List[int]
	        :rtype: List[List[int]]
	        """
	        
	        self.ans = []
	        
	        def dfs(nums, pos, path):
	            
	            self.ans.append(copy.deepcopy(path))
	            
	            d = {}
	            for i in range(pos, len(nums)):
	                
	                if nums[i] not in d:
	                
	                    dfs(nums, i+1, path+[nums[i]])
	                    
	                    d[nums[i]] = 1
	        
	        nums.sort()  # 这里无论是用dict去重，还是用前后比较去重，都要排序
	        dfs(nums, 0, [])
	        return self.ans
  
版本二：前后比较去重

	class Solution:
	    def subsetsWithDup(self, nums):
	        """
	        :type nums: List[int]
	        :rtype: List[List[int]]
	        """
	        
	        def dfs(startIndex, curSet, ans):
	            
	            ans.append(curSet)
	            
	            for i in range(startIndex, len(nums)):
	                if i != startIndex and nums[i] == nums[i-1]:
	                    continue
	                else:
	                    dfs(i+1, curSet+[nums[i]], ans)
	        
	        ans = []
	        nums.sort()
	        dfs(0, [], ans)
	        return ans

note：

1. 使用字典记录重复的值，达到去重的目的
2. 先要对序列排序是很关键的一步，只有这样才可以保证从i向后搜索不会搜到相同的数字

### word search

leetcode 第79题，图上的深搜题。
第一步，先要写个遍历循环，找到搜索的起点，也就是首字母。
第二步，从起点出发开始搜索，搜索时主要要记录已经走过的地方，这里可以使用一个二维的数组单独来记录，或者走过的地方标识为‘#’，搜索后恢复这个位置的字符。
注意，每次搜索时，都要比较word和当前路径已经遍历到的字符，这里可以使用增量式的比较方法，每次比较一个字符即可。

	class Solution:
	    def exist(self, board, word):
	        """
	        :type board: List[List[str]]
	        :type word: str
	        :rtype: bool
	        """
	        row = len(board)
	        col = len(board[0])
	        
	        def dfs(current_x, current_y, board, index, word):
	            
	            if index == len(word)-1:
	                return True
	
	            tmp = board[current_x][current_y]
	            board[current_x][current_y] = '#'
	
	            if current_x+1 < row and board[current_x+1][current_y] == word[index+1]:
	                if dfs(current_x+1, current_y, board, index+1, word):
	                    return True
	            if current_x-1 >= 0 and board[current_x-1][current_y] == word[index+1]:
	                if dfs(current_x-1, current_y, board, index+1, word):
	                    return True
	            if current_y+1 < col and board[current_x][current_y+1] == word[index+1]:
	                if dfs(current_x, current_y+1, board, index+1, word):
	                    return True 
	            if current_y-1 >= 0 and board[current_x][current_y-1] == word[index+1]:
	                if dfs(current_x, current_y-1, board, index+1, word):
	                    return True
	
	            board[current_x][current_y] = tmp
	            
	            return False
	                
	        for i in range(row):
	            for j in range(col):
	                if board[i][j] == word[0]:
	                    if dfs(i, j, board, 0, word):
	                        return True
	        return False
      
版本二：

	class Solution:
	    def exist(self, board, word):
	        """
	        :type board: List[List[str]]
	        :type word: str
	        :rtype: bool
	        """
	        
	        row = len(board)
	        col = len(board[0])
	        
	        def dfs(board, x, y, pos):
	            
	            if x < 0 or x >= row or y < 0 or y >= col:
	                return False
	            
	            if pos >= len(word):
	                return False
	            
	            if board[x][y] == word[pos]:
	                if pos == len(word) - 1:
	                    return True
	                else:
	                    tmp = board[x][y]
	                    board[x][y] = "#"
	                    
	                    if dfs(board, x+1, y, pos+1):
	                        return True
	                    if  dfs(board, x-1, y, pos+1):
	                        return True
	                    if  dfs(board, x, y+1, pos+1):
	                        return True
	                    if  dfs(board, x, y-1, pos+1):
	                        return True
	                    
	                    board[x][y] = tmp
	            else:
	                return False
	        
	        for i in range(row):
	            for j in range(col):
	                if board[i][j] == word[0]:
	                    if dfs(board, i, j, 0):
	                        return True
	        return False
                          
版本二主要改进在于判断越界调节放在dfs的头上统一判断，而不是尝试四个方向的时候单独判断。注意，这里必须要用回溯法。

### Restore IP Addresses

leetcode第93题，计算有效的IP地址。

分析问题，首先什么是有效的IP，这里有效是广义的，也就是凡是符合IP的要求的都算，不考虑特殊IP地址的限制。这样有效IP的要求就放宽了不少，首先IP应该有四级，每一个的数字都应该在0-255之间，还有一点比较隐蔽，那就是0单独出现时正确的，但是如“”010”这样的数字就是不合法的了。

确认有效IP的格式后，就要分析算法，这里运用深度搜索，递归出口条件有两个，一个是长度上不符合要求则要立刻返回，而是当递归到最后一层时需要判断首位是否为0且在0-255范围内。

递归的时候，遍历方式为从当前第一个字符开始依次向后扩展1-3个字符。

    class Solution(object):
        def restoreIpAddresses(self, s):
            """
            :type s: str
            :rtype: List[str]
            """
            def dfs(string,n):
                if len(string) > 3*n or len(string) < n: # 如果长度不符合要求则直接返回
                    return []
                if n == 1: # 考虑处理到最后的字符串的情况
                    if string[0] == '0' and len(string) > 1: # 开头是0，但不是单个的0返回
                        return []
                    if int(string) > 255: # 最后的子串超出范围返回
                        return []
                    return [string]
        
                ret = []
                for i in xrange(1,4):
                    if string[0] == '0' and i > 1: # 开头是0，不是单个的0
                        continue
                    if int(string[:i]) > 255: # 超出返回
                        continue
                    iret = dfs(string[i:],n-1) # 深搜
                    if len(iret) > 0:
                        ret += [string[:i]+'.'+iiret for iiret in iret]
                return ret
        
            return dfs(s,4)


### Unique Binary Search Trees II


    # Definition for a binary tree node.
    # class TreeNode:
    #     def __init__(self, x):
    #         self.val = x
    #         self.left = None
    #         self.right = None

    class Solution(object):
        def generateTrees(self, n):
            if n == 0:
                return []
            return self.helper(1, n)

        def helper(self, start, end):
            result = []
            if start > end:  # 出口条件是 start比end大了，此时子树为空，但还要以list形式返回，注意这里没有等于号，因为等于代表还是有单个的node存在可以返回的
                result.append(None)
                return result

            for i in range(start, end + 1):  # 从start到end，依次以i为root node

                # generate left and right sub tree
                leftTree = self.helper(start, i - 1)    # 返回的是左右子树list
                rightTree = self.helper(i + 1, end)

                # link left and right sub tree to root(i)
                for j in range(len(leftTree)):    # 分别加挂左右子树
                    for k in range(len(rightTree)):
                        root = TreeNode(i)
                        root.left = leftTree[j]
                        root.right = rightTree[k]
                        result.append(root)  # result收集本层生成的subtree，向上提交，帮助上一层构建树

            return result
note：
1. 遍历所有可能的node值，选取一个作为root节点
2. 小于root的可以作为左子树，大于root的可以作为右子树
3. 左子树和右子树同样也会生成不同的形态。

### Path Sum

    class Solution:
        
        def __init__(self):
            self.ans = False
        
        def hasPathSum(self, root, sum):
            """
            :type root: TreeNode
            :type sum: int
            :rtype: bool
            """
            
            def dfsTopDown(node, sumNum, sum):
                
                sumNum += node.val
                
                if node.left == None and node.right == None:
                    if sumNum == sum:
                        self.ans = True
                    return
                
                if node.left != None:
                    dfsTopDown(node.left, sumNum, sum)
                if node.right != None:
                    dfsTopDown(node.right, sumNum, sum)
            
            if root == None:
                return False
            dfsTopDown(root, 0, sum)
            return self.ans
note:
这里有个基本问题，就是什么时候使用回溯，什么时候不使用。比如在下面的题目中，path就要回溯，因为先执行left上的搜索，如果搜索没有完成，path此时已经把left的节点加进来了，于是应该先行pop掉left的node，才能执行right上的搜索。反之，sumNum则不需要，因为在本层sumnum并没有变化，所以无须回溯。


### Path Sum II

https://leetcode.com/problems/path-sum-ii/description/

	# Definition for a binary tree node.
	# class TreeNode:
	#     def __init__(self, x):
	#         self.val = x
	#         self.left = None
	#         self.right = None
	
	class Solution:
	    def pathSum(self, root, sum):
	        """
	        :type root: TreeNode
	        :type sum: int
	        :rtype: List[List[int]]
	        """
	        import copy
	        
	        def dfs(node, curList, curSum, ans):
	            
	            curSum += node.val
	            curList.append(node.val)
	            
	            if curSum == sum and node.left == None and node.right == None:
	                ans.append(copy.deepcopy(curList))
	            
	            if node.left:
	                dfs(node.left, curList, curSum, ans)
	            if node.right:
	                dfs(node.right, curList, curSum, ans)
	                
	            curList.pop()  # 这里pop其实是为了交给上一层的时候用的
	        
	        if not root:
	            return []
	        
	        ans = []
	        dfs(root, [], 0, ans)
	        return ans

### Path Sum III

[https://leetcode.com/problems/path-sum-iii/description/](https://leetcode.com/problems/path-sum-iii/description/)

	# Definition for a binary tree node.
	# class TreeNode:
	#     def __init__(self, x):
	#         self.val = x
	#         self.left = None
	#         self.right = None
	
	class Solution:
	    def pathSum(self, root, sum):
	        """
	        :type root: TreeNode
	        :type sum: int
	        :rtype: int
	        """
	        
	        def dfs(node, prefixSum):
	            
	            if not node:
	                return 0
	            
	            prefixSum += node.val
	
	            left = dfs(node.left, prefixSum)  # bottom up思路
	            right = dfs(node.right, prefixSum)
	            
	            return (prefixSum == sum) + left + right  # 汇总左右两边的情况与本层的情况
	            
	        
	        if not root:
	            return 0
	        return dfs(root, 0) + self.pathSum(root.left, sum) + self.pathSum(root.right, sum) # 任意节点当作root去执行dfs
	        
note：

1. 题目没有规定路径的起点和终点，所以最好的办法是把任意一个node当作是rootdfs下去。
2. 由于题目中存在负数，因此找到了一种方案后仍不能停止搜索，要继续向下dfs。      
        
        

### Number of Island'

法一：并查集

    class Solution(object):
        def numIslands(self, grid):
            """
            :type grid: List[List[str]]
            :rtype: int
            """
            row = len(grid)
            if row == 0:
                return 0
            col = len(grid[0])
            self.count = sum(grid[i][j]=='1' for i in range(row) for j in range(col))
            parent = [i for i in range(row*col)]
            def find(x):
                if parent[x] != x:
                    return find(parent[x])
                return parent[x]
            def union(x,y):
                a = find(x)
                b = find(y)
                if a == b:
                    return
                parent[a] = b
                self.count -= 1
            for i in range(row):
                for j in range(col):
                    if grid[i][j] == '0':continue
                    index = i*col+j
                    if j < col-1 and grid[i][j+1] == '1':
                        union(index,index+1)
                    if i < row-1 and grid[i+1][j] == '1':
                        union(index,index+col)
            return self.count

法二：深搜


    class Solution(object):
        def numIslands(self, grid):
            """
            :type grid: List[List[str]]
            :rtype: int
            """
            
            row = len(grid)  # 处理边界
            if row == 0:
                return 0
            col = len(grid[0])
            if col == 0:
                return 0
            
            
            res  = 0
            visit = [[0] * col for i in range(row)]
            
            def dfs(grid, visit, i, j):
                
                if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):  # 边界条件
                    return
                
                if grid[i][j] == "0" or visit[i][j] == 1:   # 已经被踩中的和0的直接返回
                    return
                
                visit[i][j] = 1   # 标记已经走过的点[https://leetcode.com/problems/target-sum/description/](https://leetcode.com/problems/target-sum/description/)
                
                dfs(grid, visit, i+1, j)   # 四个方向dfs
                dfs(grid, visit, i-1, j)
                dfs(grid, visit, i, j-1)
                dfs(grid, visit, i, j+1)  # 不需要回溯
                
            for i in range(row):
                for j in range(col):
                    if grid[i][j] == "1" and visit[i][j] == 0:
                        dfs(grid, visit, i, j)
                        res += 1
            
            return res

note：
1. 遍历整个网格，寻找合适的起始点，一旦dfs走完了，说明有一大块相邻的都被标记visit过了，因此res+1，重新寻找起始点。这样走完多少次，就应该有多少块

### Open the Lock

[https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1375/](https://leetcode.com/explore/learn/card/queue-stack/231/practical-application-queue/1375/)

本质就是个迷宫遍历的问题，只不过相邻位置不再是上下左右四个位置，而是四位数字每个都加一减一，总共有八个相邻的位置。遍历迷宫问题中求最短路径要用BFS来做。 和经典BFS遍历迷宫解法唯一不同的就是找下一个位置的地方，我们用结果res来记录BFS遍历的层数，如果此时新生成的字符串等于target了，直接返回结果res，否则我们看如果该字符串不在死锁集合里，且之前没有遍历过，那么加入队列queue中，之后将该字符串加入visited集合中，



	class Solution(object):
	    def openLock(self, deadends, target):
	        """
	        :type deadends: List[str]
	        :type target: str
	        :rtype: int
	        """
	        
	        from collections import deque
	        
	        q = deque()
	        visited = set()
	        count = 0
	        q.append(("0000", 0))
	        
	        while q:
	            
	            point, count = q.popleft()
	            
	            if point in visited:
	                continue
	            else:
	                visited.add(point)
	            
	            if point in deadends:
	                continue
	            if point == target:
	                return count
	            
	            nums = [x for x in point]
	            
	            for i in range(4):
	                
	                nums[i] = str((int(nums[i]) + 1) % 10)
	                nextpoint = "".join(nums)
	                q.append((nextpoint, count + 1))
	                
	                nums[i] = str((int(nums[i]) - 2) % 10)  # nums[i]已经被改变，所以要-2
	                nextpoint = "".join(nums)
	                q.append((nextpoint, count + 1))
	                
	                nums[i] = str((int(nums[i]) + 1) % 10)  # 这一步相当于恢复nums[i]
	        
	        return -1



                
        
### Target Sum

[https://leetcode.com/submissions/detail/173034877/](https://leetcode.com/submissions/detail/173034877/)

法一：DFS

使用递归dfs暴力搜索，这里需要注意两个地方
1. 当搜索到数组末尾的时候，就需要验证是不是和满足S这个要求，满足就res++。
2. 递归的时候，不需要内嵌一个循环，这里是按照顺序往下找的，因此把下一个元素，或加或减，加入dfs搜索就可以了

  
	class Solution {
	public:
	    int findTargetSumWays(vector<int>& nums, int S) {
	        int res = 0;
	        helper(nums, S, 0, res);
	        return res;
	    }
	    void helper(vector<int>& nums, int S, int start, int& res) {
	        if (start >= nums.size()) {
	            if (S == 0) ++res;
	            return;
	        }
	        helper(nums, S - nums[start], start + 1, res);
	        helper(nums, S + nums[start], start + 1, res);
	    }
	};

python版本，TLE

	class Solution(object):
	    def findTargetSumWays(self, nums, S):
	        """
	        :type nums: List[int]
	        :type S: int
	        :rtype: int
	        """
	        
	        self.ans = 0
	        
	        def dfs(curSum, curIndex):
	            
	            if curIndex >= len(nums):
	                if curSum == S:
	                    self.ans += 1
	                return 
	
	            dfs(curSum + nums[curIndex], curIndex + 1)
	            dfs(curSum - nums[curIndex], curIndex + 1)
	        
	        dfs(0, 0)
	        
	        return self.ans
	            

法二：DP

	class Solution(object):
	    def findTargetSumWays(self, nums, S):
	        if not nums:
	            return 0
	        dic = {nums[0]: 1, -nums[0]: 1} if nums[0] != 0 else {0: 2} # 形成第一个数字有多少种可能
	        for i in range(1, len(nums)):  # 从1开始遍历，nums[0]已经加入dp
	            tdic = {}
	            for d in dic:
	                tdic[d + nums[i]] = tdic.get(d + nums[i], 0) + dic.get(d, 0)
	                tdic[d - nums[i]] = tdic.get(d - nums[i], 0) + dic.get(d, 0)
	            dic = tdic  # 这里是一个优化trick，当前的dp之和前一个有关，因此可以只维护一个dp
	        return dic.get(S, 0)  # get方法，有可能凑不出来S，返回0

note：

1. dp使用一个hash来记录，dp[i]表示形成i的方法数有多少种可能。
2. tdic[d + nums[i]] = tdic.get(d + nums[i], 0) + dic.get(d, 0)，这里一个表示当前tdic形成d+nums[i]的种类数，另一个是dic中形成d的种类数，形成了d，加一个nums[i]就可以达到d+nums[i]。

### Clone Graph

[https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1392/](https://leetcode.com/explore/learn/card/queue-stack/232/practical-application-stack/1392/)

	# Definition for a undirected graph node
	# class UndirectedGraphNode:
	#     def __init__(self, x):
	#         self.label = x
	#         self.neighbors = []
	
	class Solution:
	    # @param node, a undirected graph node
	    # @return a undirected graph node
	    def cloneGraph(self, node):
	        
	        def dfs(node):
	            
				# 复制节点
	            cur = UndirectedGraphNode(node.label)
	            self.visit[node] = cur # 不需要检查，能递归到这一步的肯定没被访问到，直接加入即可
	            
	            for neg in node.neighbors:
	                if neg not in self.visit:
	                    cur.neighbors.append(dfs(neg)) # 加挂的是cur上，也就是新复制出来的
	                else:
	                    cur.neighbors.append(self.visit[neg])
	            return cur
	        
	        if not node:
	            return None
	        self.visit = {}
	        return dfs(node)

note：

1. 克隆图的一个难点就是一个结点的邻居可能在已经出现过
2. 复制node其实分两步，第一步，复制node的label，第二部，加挂neighbors中的node
2. 用hash存取对应的node，一个node对应一个复制出来的node
3. 深搜，同时观察是否已经被搜到，已经被搜到的直接加挂，没有被搜到的dfs递归调用加挂。     

### Flood Fill

[https://leetcode.com/explore/learn/card/queue-stack/239/conclusion/1393/](https://leetcode.com/explore/learn/card/queue-stack/239/conclusion/1393/)

	class Solution:
	    def floodFill(self, image, sr, sc, newColor):
	        """
	        :type image: List[List[int]]
	        :type sr: int
	        :type sc: int
	        :type newColor: int
	        :rtype: List[List[int]]
	        """
	        
	        def dfs(image, curx, cury, oldColor, newColor):
	            
	            row = len(image)
	            col = len(image[0])
	            
	            if curx < 0 or curx >= row or cury < 0 or cury >= col:
	                return
	            
	            if image[curx][cury] != oldColor:
	                return
	            
	            image[curx][cury] = newColor
	            
	            dfs(image, curx+1, cury, oldColor, newColor)
	            dfs(image, curx-1, cury, oldColor, newColor)
	            dfs(image, curx, cury+1, oldColor, newColor)
	            dfs(image, curx, cury-1, oldColor, newColor)
	        
	        oldColor = image[sr][sc]
	        if oldColor == newColor:
	            return image
	        dfs(image, sr, sc, oldColor, newColor)
	        return image

note：
满水填充法，将种子点及其相连通的区域全部替换为新颜色。直接用dfs深搜即可。
注意，我们在这里没有使用visit数组记录是否走到过某个位置，而是直接观察是否被填充了新颜色来判断。这里就会有一个bug，加入填充的新颜色和旧颜色是一样的，这样的判断就失效了。因此要单独验证一步，如果新旧颜色一样，直接返回即可。   

### 01 Matrix

[https://leetcode.com/explore/learn/card/queue-stack/239/conclusion/1388/](https://leetcode.com/explore/learn/card/queue-stack/239/conclusion/1388/)

BFS要用到了队列，让值为0的节点全部进入队列，代表要进行遍历的点；把值为1的点设为最大值，表示距离很远，初始状态下不能到。然后对于队列中的每个点都有四个方向，要考虑这个点临近的四个方向的点距都离为当前点到0点的距离加1.有点类似DP，把某个点到0的距离设为周围点到0的最短值+1即可。注意，遍历时修改完另外点的值的时候，一定要把这个节点也加入到队列中。这个点到0的距离是最近距离+1，而不是单纯的1.

	class Solution:
	    def updateMatrix(self, matrix):
	        """
	        :type matrix: List[List[int]]
	        :rtype: List[List[int]]
	        """
	         
	        row = len(matrix)
	        if row < 0:
	            return
	        col = len(matrix[0])
	        if col < 0:
	            return
	        
	        queue = []
	        
	        for i in range(row):
	            for j in range(col):
	                if matrix[i][j] == 0:
	                    queue.append((i, j))
	                else:
	                    matrix[i][j] = 99999999
	        
	        dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]]
	        
	        while len(queue) != 0:
	            
	            tmp = queue.pop(0)
	            
	            for dire in dirs:
	                
	                x = tmp[0]+dire[0]
	                y = tmp[1]+dire[1]
	                
	                if x < 0 or x >= row or y < 0 or y >= col or matrix[x][y] <= matrix[tmp[0]][tmp[1]]:
	                    continue
	                matrix[x][y] = matrix[tmp[0]][tmp[1]] + 1
	            
	                queue.append((x, y))
	        
	        return matrix

法二：双遍历法

这种解法也相当的巧妙，我们首先建立一个和matrix大小相等的矩阵res，初始化为很大的值，这里我们用INT_MAX-1，为甚么要减1呢，后面再说。然后我们遍历matrix矩阵，当遇到为0的位置，我们将结果res矩阵的对应位置也设为0，这make sense吧，就不多说了。然后就是这个解法的精髓了，如果不是0的地方，我们在第一次扫描的时候，比较其左边和上边的位置，取其中较小的值，再加上1，来更新结果res中的对应位置。这里就明白了为啥我们要初始化为INT_MAX-1了吧，因为这里要加1，如果初始化为INT_MAX就会整型溢出，不过放心，由于是取较小值，res[i][j]永远不会取到INT_MAX，所以不会有再加1溢出的风险。第一次遍历我们比较了左和上的方向，那么我们第二次遍历就要比较右和下的方向，注意两种情况下我们不需要比较，一种是当值为0时，还有一种是当值为1时，这两种情况下值都不可能再变小了，所以没有更新的必要，

	class Solution {
	public:
	    vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) {
	        int m = matrix.size(), n = matrix[0].size();
	        vector<vector<int>> res(m, vector<int>(n, INT_MAX - 1));
	        for (int i = 0; i < m; ++i) {
	            for (int j = 0; j < n; ++j) {
	                if (matrix[i][j] == 0) res[i][j] = 0;
	                else {
	                    if (i > 0) res[i][j] = min(res[i][j], res[i - 1][j] + 1);
	                    if (j > 0) res[i][j] = min(res[i][j], res[i][j - 1] + 1);
	                }
	            }
	        }
	        for (int i = m - 1; i >= 0; --i) {
	            for (int j = n - 1; j >= 0; --j) {
	                if (res[i][j] != 0 && res[i][j] != 1) {
	                    if (i < m - 1) res[i][j] = min(res[i][j], res[i + 1][j] + 1);
	                    if (j < n - 1) res[i][j] = min(res[i][j], res[i][j + 1] + 1);
	                }
	            }
	        }
	        return res;
	    }
	};
                
   
### Keys and Rooms
         
[https://leetcode.com/explore/learn/card/queue-stack/239/conclusion/1391/](https://leetcode.com/explore/learn/card/queue-stack/239/conclusion/1391/)

	class Solution:
	    def canVisitAllRooms(self, rooms):
	        """
	        :type rooms: List[List[int]]
	        :rtype: bool
	        """
	        
	        def dfs(rooms, curRoom, visit):
	            
	            visit[curRoom] = 1
	            for key in rooms[curRoom]:
	                if visit[key] == 0:  # 递归是在这里停止的，当所有visit都被访问到了，或者有的key找不到对应的room，此循环停止，不在dfs调用
	                    dfs(rooms, key, visit)
	        
	        visit = [0] * len(rooms)
	        
	        dfs(rooms, 0, visit)
	        
	        return sum(visit) == len(rooms)

### Sudoku Solver

[https://leetcode.com/problems/sudoku-solver/description/](https://leetcode.com/problems/sudoku-solver/description/)

	class Solution:
	    def solveSudoku(self, board):
	        """
	        :type board: List[List[str]]
	        :rtype: void Do not return anything, modify board in-place instead.
	        """
	        
	        def check(borad, i, j): # 检查的时候注意要排除自身（row != i，col != j）
	            for row in range(9):
	                if board[i][j] == board[row][j] and row != i:
	                    return False
	            for col in range(9):
	                if board[i][j] == board[i][col] and col != j:
	                    return False
	            for row in range(i//3*3, i//3*3+3):  # 九宫格的遍历方式
	                for col in range(j//3*3, j//3*3+3):
	                    if board[row][col] == borad[i][j] and row != i and col != j:
	                        return False
	            return True
	                
	        
	        def solve(board, i, j):
	            
	            if i == 9:
	                return True
	            if j >= 9:
	                return solve(board, i+1, 0)  # 一行扫描结束，扫描下一行
	            
	            if board[i][j] == ".":
	                for k in range(1, 10):
	                    board[i][j] = str(k)
	                    if check(board, i, j):
	                        if solve(board, i, j+1):
	                            return True
	                    board[i][j] = "."  # 回溯
	            else:
	                return solve(board, i, j+1)
	            
	            return False
	        
	        solve(board, 0, 0)
	 
dfs+回溯。逐行扫描，遇到没有填的数就开始从1-9开始尝试，尝试过程中不断check是否满足数独要求，如果满足要求了，就向后继续搜索。
难点在于怎么check。首先check新加入的数字是否符合要求，要进行行和列的检查。然后再自己的九宫格内还要检查。   


### Regular Expression Matching

[https://leetcode.com/problems/regular-expression-matching/description/](https://leetcode.com/problems/regular-expression-matching/description/)

	class Solution:
	    def isMatch(self, s, p):
	        """
	        :type s: str
	        :type p: str
	        :rtype: bool
	        """
	        
	        def match(s, p):
	            if  len(p) == 0:
	                return len(s) == 0
	            if len(p) == 1:
	                return len(s) == 1 and (s[0] == p[0] or p[0] == ".")
	            if p[1] != "*":
	                if len(s) == 0:
	                    return False
	                return (s[0] == p[0] or p[0] == ".") and match(s[1:], p[1:])
	            
	            while (len(s) != 0 and (s[0] == p[0] or p[0] == ".")):
	                if match(s, p[2:]):
	                    return True
	                s = s[1:]
	            return match(s, p[2:])
	        
	        ans = match(s, p)
	        return ans
            
- 若p为空，若s也为空，返回true，反之返回false
- 若p的长度为1，若s长度也为1，且相同或是p为'.'则返回true，反之返回false
- 若p的第二个字符不为*，若此时s为空返回false，否则判断首字符是否匹配，且从各自的第二个字符开始调用递归函数匹配
- 若p的第二个字符为*，若s不为空且字符匹配，调用递归函数匹配s和去掉前两个字符的p，若匹配返回true，否则s去掉首字母 
- 返回调用递归函数匹配s和去掉前两个字符的p的结果    
                    
	
	
### Generate Parentheses

[https://leetcode.com/problems/generate-parentheses/description/](https://leetcode.com/problems/generate-parentheses/description/)

	class Solution(object):
	    def generateParenthesis(self, n):
	        """
	        :type n: int
	        :rtype: List[str]
	        """
	        def dfs(n,s,l,r,ans):
	            if (l == n):
	                ans.append(s+(n-r)*")")
	                return
	            else:
	                dfs(n,s+"(",l+1,r,ans)
	                if (l > r):
	                    dfs(n,s+")",l,r+1,ans)
	        ans = []
	        if n > 0:
	            dfs(n,"",0,0,ans)
	        else:
	            return [""]
	        return ans

括号匹配生成的时候，面临着两种选择，一个是加入右括号，一个是加入左括号，那么什么时候加入左括号，什么时候加入右括号呢？首先，一开始一定是左括号开头，下一步可以加左括号，也可以加右括号，原因是目前左括号的数目为1，比右括号数目0要大，因此可以匹配上。这样就可以写出递归函数了，这里注意递归的出口条件是，左括号的个数等于给定的数字时，意味着匹配结束，那么加上剩余的右括号就可以了。
  

### N-Queens

[https://leetcode.com/problems/n-queens/description/](https://leetcode.com/problems/n-queens/description/)

	class Solution(object):
	    def solveNQueens(self, n):
	        """
	        :type n: int
	        :rtype: List[List[str]]
	        """
	
	        def isvalid(c, row, col):
	            for i in range(row):
	                if c[i] == col:
	                    return False
	                if abs(i-row)==abs(c[i]-col): # 对角线验证
	                    return False
	            return True
	
	        def dfs(c, result, row):
	            if row == n:
	                solution = []
	                for i in range(n):
	                    s = ["."]*n
	                    for j in range(n):
	                        if c[i] ==  j:
	                            s[j] = "Q"
	                    s = "".join(s)
	                    solution.append(s)
	                result.append(solution)
	
	            for i in range(n):
	                flag = isvalid(c, row, i)
	                if not flag:
	                    continue
	                c[row] = i
	                dfs(c, result, row+1)
	
	        c = [0*i for i in range(n)]
	        result = []
	        dfs(c, result, 0)
	        return result   

n皇后问题，在n*n的格子中防止n个皇后，使得每一行每一列和对角线都不能出现两个以上的皇后。
这其实就是著名的八皇后问题。

简单一点切入，假设我们放置第一个皇后，我们可以任意去选择位置，一共有n^2个位置，之后就是n^2-1个可能，以此类推，之后检查每种可能性是否合法，显然这个办法复杂度太高了。

换个角度，在放置的时候，我们就先验地加入规则限制。放置第一个皇后，可以在n行中任选一行，第二个皇后，因为不能同一行，所以只有n-1中可能了，另外还要满足列要求和对角线要求。

具体一点，我们逐行进行深搜。每次搜索时，都试探不同的列，看是否满足要求，对于满足要求的列扩展状态，继续下一行的递归搜索。当搜索到行数为n时，就拉出所有的搜索结果。

**注意，这里我们维护一个list c作为棋盘的记录，c[i]=j代表了第i行中那j列有皇后。**

### N-Queens II

[https://leetcode.com/problems/n-queens-ii/description/](https://leetcode.com/problems/n-queens-ii/description/)

	class Solution(object):
	    def totalNQueens(self, n):
	        """
	        :type n: int
	        :rtype: int
	        """
	        self.counter = 0
	
	        def isvalid(c, row, col):
	            for i in range(row):
	                if c[i] == col:
	                    return False
	                if abs(i-row) == abs(c[i]-col):
	                    return False
	            return True
	
	        def dfs(c, row):
	            if row == n:
	                self.counter += 1
	            for i in range(n):
	                flag = isvalid(c, row, i)
	                if not flag:
	                    continue
	                c[row] = i
	                dfs(c, row+1)
	
	        c = [0*i for i in range(n)]
	        counter = 0
	        dfs(c, 0)
	        return self.counter
    
            
        
            
            
            
              
        