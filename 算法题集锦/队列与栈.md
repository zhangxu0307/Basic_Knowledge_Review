


## 栈 stack


### 队列与栈

### 实现一个队列，使用循环数组

	class MyCircularQueue(object):
	    def __init__(self, k):
	        self.k = k  
	        self.data = [None for i in range(self.k)]
	        self.front = self.rear = -1
	        self.size = 0  
	
	    def enQueue(self, value):
	        if self.isFull():
	            return False
	        if self.isEmpty():
	            self.front = 0
	        self.rear = (self.rear + 1) % self.k
	        self.data[self.rear] = value
	        self.size += 1
	        return True
	
	    def deQueue(self):
	        if self.isEmpty():
	            return False
	        if self.front == self.rear:
	            self.front = -1
	            self.rear = -1
	            self.size = 0
	        else:
	            self.front = (self.front + 1) % self.k
	            self.size -= 1
	        return True
	
	    def Front(self):
	        if not self.isEmpty():
	            return self.data[self.front]
	        return -1
	
	    def Rear(self):
	        if not self.isEmpty():
	            return self.data[self.rear]
	        return -1
	
	    def isEmpty(self):
	        return self.size == 0
	
	    def isFull(self):
	        return self.size == self.k


### 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

栈是先进后出，队列是先进先出。
要想实现先进入的元素先出去，其实很简单，就是把把压入第一个栈的元素在反过来压到第二个栈里，这样顺序就正好反过来了。
原理简单，实现时还要考虑几个细节。

 - 从第一个栈压入第二个栈什么时候操作？简单，当第二个栈被弹空了，或者刚开始什么都没有，就需要从第一个栈里拿数据了。也就是说，只有我要弹出数据时，这个操作才有必要做。
 - 弹出的过程中再次压入队列是否有问题？没有问题。如果弹出的过程中，又压入队列，并不影响整个队列的顺序。


	class Solution
	{
	    public:
	        void push(int node) {
	            stack1.push(node);
	        }
	
	        int pop() {
	            if (stack2.size()<=0)
	            {
	                while(!stack1.empty())
	                {
	                    int data = stack1.top();
	                    stack1.pop();
	                    stack2.push(data);
	                }
	            }
	            int res = stack2.top();
	            stack2.pop();
	            return res;
	        }
	
	    private:
	        stack<int> stack1;
	        stack<int> stack2;
	};

类似的还有用栈来模拟队列，这里我们不考虑使用STL的queue中back方法，只使用最原始的队列先进先出的原则模拟。
这里思路上和上面有所不同，前面实际上是要用第二个栈把第一个栈的顺序反过来，这个题目就不是这样了，是用第二个队列先把第一个队列的数存起来，这样方便拿到最末尾的数，因此代码上写起来还是不太一样的。


	class Solution
	{
	    public:
	        void push(int node) {
	            if (!queue1.empty())
	                queue1.push(node);
	            if (!queue2.empty())
	                queue2.push(node);
	            if (queue1.empty() && queue2.empty())
	                queue1.push(node);
	        }
	
	        int pop() {
	
	            if (!queue1.empty())
	            {
	                while (queue1.size() > 1)
	                {
	                    int data = queue1.front();
	                    queue1.pop();
	                    queue2.push(data);
	                }
	                int res = queue1.front();
	                queue1.pop();
	                return res;
	            }
	            else if (!queue2.empty())
	            {
	                while (queue2.size() > 1)
	                {
	                    int data = queue2.front();
	                    queue2.pop();
	                    queue1.push(data);
	                }
	                int res = queue2.front();
	                queue2.pop();
	                return res;
	            }
	        }
	
	    private:
	        queue<int> queue1;
	        queue<int> queue2;
	};



### Score of Parentheses

Given a balanced parentheses string S, compute the score of the string based on the following rule:

- () has score 1
- AB has score A + B, where A and B are balanced parentheses strings.
- (A) has score 2 * A, where A is a balanced parentheses string.



```
class Solution:
    def scoreOfParentheses(self, S):
        """
        :type S: str
        :rtype: int
        """
        stack = []
        
        for c in S:
            if c == "(":
                stack.append(-1) # 以-1作为标记
            else:
                cur = 0
                while(stack[-1] != -1):  # 把配对之前的分数都加起来
                    cur += stack.pop()
                stack.pop()  # 跑掉当前）配对的（代表的-1
                if cur == 0:  # 如果没有中间的分数，证明是直接配对的括号，1分
                    stack.append(1)
                else:
                    stack.append(cur*2)  # 用中间配对的分数，加倍
        
        ans = 0
        while len(stack) != 0:  # 遍历分数栈，可能会有多个分散的括号组合，因此加和
            ans += stack.pop()
        
        return ans
```

### Valid Parentheses

```
class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        d = {'(':')','{':'}','[':']'}
        stack = []
        n = len(s)
        for i in range(n):
            if s[i] == '(' or s[i] == '[' or s[i] == '{':
                stack.append(s[i])
            if s[i] == ')' or s[i] == ']' or s[i] == '}':
                if len(stack) == 0:
                    return False
                elif d[stack[-1]] == s[i]:
                    del stack[-1]
                else:
                    return False
        if len(stack) == 0:
            return True
        else:
            return False
```

### Simplify Path

leetcode第71题，要求化简linux风格的路径。

这里首先要明确linux路径的表示形式，一般而言，“.”代表当前目录，所以不用做处理，“..”代表返回上一次目录，因此就需要跳到前面那一层目录下。

很明显，这个题用栈来做会很简单，先用“/”分割字符串，然后凡是遇到“.”的情况，一律越过，不作处理，遇到字符则加入栈，遇到“..”则弹出栈，最后连接一下就可以了。

```
class Solution(object):
    def simplifyPath(self, path):
        """
        :type path: str
        :rtype: str
        """

        paths = [p for p in path.split("/") if p != "." and p != ""]
        print paths
        stack = []
        for p in paths:
            if p == "..":
                if len(stack) != 0:
                    stack.pop()
            else:
                stack.append(p)
        return "/"+"/".join(stack)
```


