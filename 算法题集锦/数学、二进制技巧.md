## 数学、二进制技巧

### Climbing Stairs

迭代法

	class Solution(object):
	    def climbStairs(self, n):
	        """
	        :type n: int
	        :rtype: int
	        """
	        n += 2
	        before = 1
	        beforer = 1
	        for i in range(2,n):
	            tmp = beforer
	            beforer = before
	            before = tmp+beforer
	        return beforer
            


递归法


	def climbStairs(n):
	    if n == 0:
	        return 1
	    if n == 1:
	        return 1
	    elif n == 2:
	        return 2
	    elif n > 2:
	        return climbStairs(n-1)+climbStairs(n-2)

### Reach a Number

You are standing at position 0 on an infinite number line. There is a goal at position target.
On each move, you can either go left or right. During the n-th move (starting from 1), you take n steps.
Return the minimum number of steps required to reach the destination.


	class Solution:
	    def reachNumber(self, target):
	        """
	        :type target: int
	        :rtype: int
	        """
	        
	        target = abs(target)
	        
	        res = 0
	        sumNum = 0
	        while sumNum < target or (sumNum - target) % 2 ==1:
	            res += 1
	            sumNum += res
			return res
        

[https://www.cnblogs.com/grandyang/p/8456022.html](https://www.cnblogs.com/grandyang/p/8456022.html)


### Single Number

[https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1176/](https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1176/)

	class Solution {
	public:
	    int singleNumber(vector<int>& nums) {
	        int ans = nums[0];
	        for(int i = 1; i < nums.size();i++)
	        {
	            ans = ans ^ nums[i];
	        }
	        return ans;
	    }
	};

只有一个数字没有出现两次，其余的均出现两次，那么这些数字异或之后应该就是0，而0异或那个单独的数字就是这个数字本身，即为所求。

### Number of 1 Bits


	class Solution {
	public:
	    int hammingWeight(uint32_t n) {
	        int count = 0;
	        while(n)
	        {
	            count++;
	            n = n&(n-1);
	        }
	        return count;
	    }
	};

note:
把一个数减去1和本身与运算，结果相当于把这个数最右边的1变成了0

1. 判断是否是2的整数次方，把其中唯一的1变成0即可
2. 两个整数m和n，改变m中的二进制多少位可以变成n，先异或，在统计1的个数


###  Rectangle Area

[https://leetcode.com/problems/rectangle-area/description/](https://leetcode.com/problems/rectangle-area/description/)

基本思路：算出两个矩形面积之和，减去交集面积即可。关键在于交集面积如何求解。
求交集区域的长和宽也不难，由于交集都是在中间，**所以横边的左端点是两个矩形左顶点横坐标的较大值，右端点是两个矩形右顶点的较小值，同理，竖边的下端点是两个矩形下顶点纵坐标的较大值，上端点是两个矩形上顶点纵坐标的较小值。**

	class Solution(object):
	    def computeArea(self, A, B, C, D, E, F, G, H):
	        """
	        :type A: int
	        :type B: int
	        :type C: int
	        :type D: int
	        :type E: int
	        :type F: int
	        :type G: int
	        :type H: int
	        :rtype: int
	        """
	        area = (D-B)*(C-A)+(G-E)*(H-F)
	        lx = max(A, E)
	        rx = min(C, G)
	        ly = max(B, F)
	        hy = min(D, H)
	        if lx >= rx or ly >= hy:
	            return area
	        return area - (rx-lx)*(hy-ly)


### Course Schedule

[https://leetcode.com/problems/course-schedule/description/](https://leetcode.com/problems/course-schedule/description/)

给定一组课程的互相的优先关系，判断是否可以满足课程上完的要求。

这个问题很典型是拓扑排序，抽象出来就是每个课程都是一个节点，题目的意思就是经过拓扑排序之后去掉节点后图中是否还有剩余，如果有说明图中存在环结构。

拓扑排序思想很简单，图中节点有优先关系，将入度为零的节点加入队列，然后与这个节点相关的节点入度自动递减，重复上述过程，如果满足图中无环的情况，就应该会没有节点剩余，如果有，就说明存在环。

具体代码实现，用字典记录节点的依存关系，另外用一个列表记录每个节点的入度。



	class Solution(object):
	    def canFinish(self, numCourses, prerequisites):
	        """
	        :type numCourses: int
	        :type prerequisites: List[List[int]]
	        :rtype: bool
	        """
	        nodes = {}
	        degree = [0]*numCourses
	        n = len(prerequisites)
	        for i in range(n):
	            if prerequisites[i][1] not in nodes:
	                nodes[prerequisites[i][1]] = [prerequisites[i][0]]  # 记录node指向的nodes，方便删入度
	                degree[prerequisites[i][0]] += 1
	            else:
	                nodes[prerequisites[i][1]].append(prerequisites[i][0])
	                degree[prerequisites[i][0]] += 1
	        print nodes
	    
	        queue = []
	        counter = 0
	        for i in range(numCourses):
	            if degree[i] == 0:
	                queue.append(i)
	    
	        while len(queue) != 0:
	            head = queue[0]
	            del queue[0]
	            counter += 1
	            if head in nodes:
	                for i in nodes[head]:
	                    degree[i] -= 1
	                    if degree[i] == 0:  # 入度为0的加入队列
	                        queue.append(i)
	        print counter
	        return counter == numCourses

### Nim Game

[https://leetcode.com/submissions/detail/69370886/](https://leetcode.com/submissions/detail/69370886/)

	class Solution(object):
	    def canWinNim(self, n):
	        """
	        :type n: int
	        :rtype: bool
	        """
	        if n == 0:
	            return False
	        if n%4 == 0:
	            return False
	        else:
	            return True

由于是我们先拿，那么3个以内(包括3个)的石子，我们直接赢，如果共4个，那么我们一定输，因为不管我们取几个，下一个人一次都能取完。如果共5个，我们赢，因为我们可以取一个，然后变成4个让别人取，根据上面的分析我们赢，所以我们列出1到10个的情况如下：

1    Win

2    Win

3    Win

4    Lost

5    Win

6    Win

7    Win

8    Lost

9    Win

10   Win

由此我们可以发现规律，只要是4的倍数个，我们一定会输，所以对4取余即可.

讨论：我们来generalize一下这道题，当可以拿1～n个石子时，那么个数为(n+1)的整数倍时一定会输，我们试着证明一下这个结论，若当前共有m*(n+1)个石子，那么：

当m=1时，即剩n+1个的时候，肯定会输，因为不管你取1～n中的任何一个数字，另一个人都可以取完。
当m>1时，即有m*(n+1)的时候，不管你先取1～n中的任何一个数字x，另外一个人一定会取n+1-x个，这样总数就变成了(m-1)*(n+1)，第二个人就一直按这个策略取，那么直到剩n+1个的时候，就便变成m=1的情况，一定会输。

### Bulb Switcher

[https://leetcode.com/problems/bulb-switcher/description/](https://leetcode.com/problems/bulb-switcher/description/)

	class Solution:
	    def bulbSwitch(self, n):
	        """
	        :type n: int
	        :rtype: int
	        """
	        
	        res = 1
	    
	        while res * res <= n:
	            res += 1
	        
	        return res - 1
        
比如只有5个灯泡的情况，'X'表示灭，‘√’表示亮，如下所示：

初始状态：    X    X    X    X    X

第一次：      √    √    √    √    √

第二次：      √     X    √    X    √

第三次：      √     X    X    X    √

第四次：      √     X    X    √    √

第五次：      √     X    X    √    X

那么最后我们发现五次遍历后，只有1号和4号灯泡是亮的，而且很巧的是它们都是平方数，是巧合吗，还是其中有什么玄机。我们仔细想想，对于第n个灯泡，只有当次数是n的因子的之后，才能改变灯泡的状态，即n能被当前次数整除，比如当n为36时，它的因数有(1,36), (2,18), (3,12), (4,9), (6,6), 可以看到前四个括号里成对出现的因数各不相同，括号中前面的数改变了灯泡状态，后面的数又变回去了，等于灯泡的状态没有发生变化，只有最后那个(6,6)，在次数6的时候改变了一次状态，没有对应其它的状态能将其变回去了，所以灯泡就一直是点亮状态的。所以所有平方数都有这么一个相等的因数对，即所有平方数的灯泡都将会是点亮的状态。






        

