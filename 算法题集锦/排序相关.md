## 排序及相关

### 快速排序


```

def partition(nums, start, end): # 注意，这个函数的start和end表示要partition的段，所以所有操作都在要在statr和end上做

    if len(nums) <= 0 or start < 0 or end >= len(nums):  # 检查下表是否合法
        return -1

    base = nums[end]  # 直接选取末尾数字作为基准点

    small = start-1  # small初始化为前一格

    for i in range(start, end): # start~end-1，end已经是基准点了
        if nums[i] < base:
            small += 1  # 先移动，在交换
            if small != i:
                nums[i], nums[small] = nums[small], nums[i]

    small += 1  # small指向第一个比base大的数字
    nums[end], nums[small] = nums[small], nums[end]
    return small


def quickSort(nums, start, end):

    if start == end:  # 递归出口条件是，start和end重合了
        return

    index = partition(nums, start, end)  # 先做partition，再递归quicksort

    if index > start:
        quickSort(nums, start, index-1)
    if index < end:
        quickSort(nums, index+1, end)
```

### 寻找第k小的元素和前k小的元素


```
def findKthSmall(nums, k):

    k -= 1  # 第k大的数，实际上在数组中是k-1那个位置的数
    start = 0
    end = len(nums) - 1
    index = partition(nums, start, end)
    while index != k:  # 注意这里是循环，知道找到index是k为止
        if index < k:
            index = partition(nums, index + 1, end) # 这里并没有递归，都是在这个函数调用partition
        if index > k:
            index = partition(nums, start, index-1)
    return nums[index]


def findKSmall(nums, k):

    k -= 1
    start = 0
    end = len(nums) - 1
    index = partition(nums, start, end)
    while index != k:
        if index < k:
            index = partition(nums, index + 1, end)
        if index > k:
            index = partition(nums, start, index - 1)
    ans = []
    for i in range(start, index+1):
        ans.append(nums[i])
    return ans
```
注意：如果是找前k大或者第k大的元素时，只需要变动partition中if nums[i] < base小于号即可。


### 归并排序


### 逆序对
> 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P

简单思路是，挨个遍历数组中的元素，每遍历到一个元素之后和后面的元素再逐一比较，这样的复杂度是O(n^2)。
这里时间都花费在了逐一比较上，这样一个个找逆序对显然是比较耗时的。归并排序的思路就是一次性的找出一串来，所以复杂度会低很多，本质就是归并排序的复杂度O(nlogn)。
首先写一个归并排序，只需要做一丁点修改就可以找出逆序对。归并排序假设左右两个子数组都是有序的，然后再merge成一个大的数组，在merge的过程中，如果前面子数组中某一元素的比后面子数组的某个元素大，那么他肯定后面子数组这个元素之前的所有数都要大，也就是都形成了逆序对，这样一来，一次性就找出了一串逆序对，而不是一个个的找。
另外注意，我们一边找逆序对，一边还要排序，这样做是为了防止重复找已经找到的逆序对。

```

int merge(vector<int> &data, int start, int mid, int end)
{
    vector<int> tmp;
    int i = start;
    int j = mid+1; // 右半部子数组开头是mid+1，因为下面右半部子数组不包含mid
    int cnt = 0;

    while(i <= mid && j <= end)
    {
        if(data[i] <= data[j])
        {
            tmp.push_back(data[i]);
            i++;
        }
        else {
            cnt += j-mid; // 逆序对，从j开始一直到第二个子数组的头部，都够成了逆序对
            tmp.push_back(data[j]);
            j++;
        }
    }

    // 剩余的子数组merge到tmp
    while(i <= mid)
    {
        tmp.push_back(data[i]);
        i++;
    }

    while (j <= end)
    {
        tmp.push_back(data[j]);
        j++;
    }

    for(i=0; i<tmp.size(); i++) // 还需要将排序好的数组复制回原数组
        data[start+i] = tmp[i];

    return cnt;

}

int mergeSort(vector<int> &data, int start, int end)
{
    int cnt = 0;
    if(start < end)
    {
        int mid = (start + end)/2;

        cnt += mergeSort(data, start, mid); //左半部分 包含mid

        cnt += mergeSort(data, mid+1, end); //右半部分 不包含mid

        cnt += merge(data, start, mid, end); //合并两部分，并计算数量

    }

    return cnt;

}


int InversePairs(vector<int> &data)
{
    return mergeSort(data, 0, data.size()-1);
}

```


python版本


```
def merge(nums, start, mid, end):

    i = start
    j = mid + 1
    tmp = []
    cnt = 0

    while i <= mid and j <= end:
        if nums[i] > nums[j]:
            cnt += j-mid
            tmp.append(nums[j])
            j += 1
        else:
            tmp.append(nums[i])
            i += 1

    while i <= mid:
        tmp.append(nums[i])
        i += 1

    while j <= end:
        tmp.append(nums[j])
        j += 1

    for i in range(len(tmp)):
        nums[start+i] = tmp[i]
    return cnt


def mergeSort(nums, start, end):
    cnt = 0
    if start < end:
        mid = (start + end) // 2
        cnt += mergeSort(nums, start, mid)
        cnt += mergeSort(nums, mid+1, end)
        cnt += merge(nums, start, mid, end)
    return cnt

```


补充：

### 冒泡排序

    public class BubbleSort {
    　　public static void main(String[] args) {
    　　　　int[] arr={6,3,8,2,9,1};
    　　　　System.out.println("排序前数组为：");
    　　　　for(int num:arr){
    　　　　　　System.out.print(num+" ");
    　　　　}
    　　　　for(int i=0;i<arr.length-1;i++){//外层循环控制排序趟数，这里有-1，因为后面有j+1
    　　　　　　for(int j=0;j<arr.length-1-i;j++){//内层循环控制每一趟排序多少次
    　　　　　　　　if(arr[j]>arr[j+1]){
    　　　　　　　　　　int temp=arr[j];
    　　　　　　　　　　arr[j]=arr[j+1];
    　　　　　　　　　　arr[j+1]=temp;
    　　　　　　　　}
    　　　　　　}
    　　　　} 
    　　　　System.out.println();
    　　　　System.out.println("排序后的数组为：");
     　　　　for(int num:arr){
     　　　　　　System.out.print(num+" ");
     　　　　} 
    　　}
     }