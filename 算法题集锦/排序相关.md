## 排序及相关

### 快速排序


```

def partition(nums, start, end): # 注意，这个函数的start和end表示要partition的段，所以所有操作都在要在statr和end上做

    if len(nums) <= 0 or start < 0 or end >= len(nums):  # 检查下表是否合法
        return -1

    base = nums[end]  # 直接选取末尾数字作为基准点

    small = start-1  # small初始化为前一格

    for i in range(start, end): # start~end-1，end已经是基准点了
        if nums[i] < base:
            small += 1  # 先移动，在交换
            if small != i:
                nums[i], nums[small] = nums[small], nums[i]

    small += 1  # small指向第一个比base大的数字
    nums[end], nums[small] = nums[small], nums[end]
    return small


def quickSort(nums, start, end):

    if start == end:  # 递归出口条件是，start和end重合了
        return

    index = partition(nums, start, end)  # 先做partition，再递归quicksort

    if index > start:
        quickSort(nums, start, index-1)
    if index < end:
        quickSort(nums, index+1, end)
```

### 寻找第k小的元素和前k小的元素


```
def findKthSmall(nums, k):

    k -= 1  # 第k大的数，实际上在数组中是k-1那个位置的数
    start = 0
    end = len(nums) - 1
    index = partition(nums, start, end)
    while index != k:  # 注意这里是循环，知道找到index是k为止
        if index < k:
            index = partition(nums, index + 1, end) # 这里并没有递归，都是在这个函数调用partition
        if index > k:
            index = partition(nums, start, index-1)
    return nums[index]


def findKSmall(nums, k):

    k -= 1
    start = 0
    end = len(nums) - 1
    index = partition(nums, start, end)
    while index != k:
        if index < k:
            index = partition(nums, index + 1, end)
        if index > k:
            index = partition(nums, start, index - 1)
    ans = []
    for i in range(start, index+1):
        ans.append(nums[i])
    return ans
```
注意：如果是找前k大或者第k大的元素时，只需要变动partition中if nums[i] < base小于号即可。


### 归并排序


### 逆序对
> 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P

简单思路是，挨个遍历数组中的元素，每遍历到一个元素之后和后面的元素再逐一比较，这样的复杂度是O(n^2)。
这里时间都花费在了逐一比较上，这样一个个找逆序对显然是比较耗时的。归并排序的思路就是一次性的找出一串来，所以复杂度会低很多，本质就是归并排序的复杂度O(nlogn)。
首先写一个归并排序，只需要做一丁点修改就可以找出逆序对。归并排序假设左右两个子数组都是有序的，然后再merge成一个大的数组，在merge的过程中，如果前面子数组中某一元素的比后面子数组的某个元素大，那么他肯定后面子数组这个元素之前的所有数都要大，也就是都形成了逆序对，这样一来，一次性就找出了一串逆序对，而不是一个个的找。
另外注意，我们一边找逆序对，一边还要排序，这样做是为了防止重复找已经找到的逆序对。

```

int merge(vector<int> &data, int start, int mid, int end)
{
    vector<int> tmp;
    int i = start;
    int j = mid+1; // 右半部子数组开头是mid+1，因为下面右半部子数组不包含mid
    int cnt = 0;

    while(i <= mid && j <= end)
    {
        if(data[i] <= data[j])
        {
            tmp.push_back(data[i]);
            i++;
        }
        else {
            cnt += j-mid; // 逆序对，从j开始一直到第二个子数组的头部，都够成了逆序对
            tmp.push_back(data[j]);
            j++;
        }
    }

    // 剩余的子数组merge到tmp
    while(i <= mid)
    {
        tmp.push_back(data[i]);
        i++;
    }

    while (j <= end)
    {
        tmp.push_back(data[j]);
        j++;
    }

    for(i=0; i<tmp.size(); i++) // 还需要将排序好的数组复制回原数组
        data[start+i] = tmp[i];

    return cnt;

}

int mergeSort(vector<int> &data, int start, int end)
{
    int cnt = 0;
    if(start < end)
    {
        int mid = (start + end)/2;

        cnt += mergeSort(data, start, mid); //左半部分 包含mid

        cnt += mergeSort(data, mid+1, end); //右半部分 不包含mid

        cnt += merge(data, start, mid, end); //合并两部分，并计算数量

    }

    return cnt;

}


int InversePairs(vector<int> &data)
{
    return mergeSort(data, 0, data.size()-1);
}

```


python版本


```
def merge(nums, start, mid, end):

    i = start
    j = mid + 1
    tmp = []
    cnt = 0

    while i <= mid and j <= end:
        if nums[i] > nums[j]:
            cnt += j-mid
            tmp.append(nums[j])
            j += 1
        else:
            tmp.append(nums[i])
            i += 1

    while i <= mid:
        tmp.append(nums[i])
        i += 1

    while j <= end:
        tmp.append(nums[j])
        j += 1

    for i in range(len(tmp)):
        nums[start+i] = tmp[i]
    return cnt


def mergeSort(nums, start, end):
    cnt = 0
    if start < end:
        mid = (start + end) // 2
        cnt += mergeSort(nums, start, mid)
        cnt += mergeSort(nums, mid+1, end)
        cnt += merge(nums, start, mid, end)
    return cnt

```


补充：

### 冒泡排序

    public class BubbleSort {
    　　public static void main(String[] args) {
    　　　　int[] arr={6,3,8,2,9,1};
    　　　　System.out.println("排序前数组为：");
    　　　　for(int num:arr){
    　　　　　　System.out.print(num+" ");
    　　　　}
    　　　　for(int i=0;i<arr.length-1;i++){//外层循环控制排序趟数，这里有-1，因为后面有j+1
    　　　　　　for(int j=0;j<arr.length-1-i;j++){//内层循环控制每一趟排序多少次
    　　　　　　　　if(arr[j]>arr[j+1]){
    　　　　　　　　　　int temp=arr[j];
    　　　　　　　　　　arr[j]=arr[j+1];
    　　　　　　　　　　arr[j+1]=temp;
    　　　　　　　　}
    　　　　　　}
    　　　　} 
    　　　　System.out.println();
    　　　　System.out.println("排序后的数组为：");
     　　　　for(int num:arr){
     　　　　　　System.out.print(num+" ");
     　　　　} 
    　　}
     }


### Sort List

[https://leetcode.com/problems/sort-list/description/](https://leetcode.com/problems/sort-list/description/)

法一：链表版归并排序

	# Definition for singly-linked list.
	# class ListNode:
	#     def __init__(self, x):
	#         self.val = x
	#         self.next = None
	
	class Solution:
	    
	    def merge(self, head1, head2):
	
	        dummy = ListNode(-1)
	        p = dummy
	
	        while head1 and head2:
	            if head1.val <= head2.val:
	                p.next = head1
	                head1 = head1.next
	            else:
	                p.next = head2
	                head2 = head2.next
	            p = p.next
	            p.next = None
	
	        if head1:
	            p.next = head1
	
	        if  head2:
	            p.next = head2
	
	        return dummy.next
	
	    def getMid(self, head):
	        
	        
	        fast = head
	        slow = head
	
	        while fast.next and fast.next.next:
	            fast = fast.next.next
	            slow = slow.next
	
	        return slow
	    
	    def sortList(self, head):
	        """
	        :type head: ListNode
	        :rtype: ListNode
	        """
	        
	        if head == None or head.next == None:
	            return head
	    
	        head1 = head
	        mid = self.getMid(head)
	        head2 = mid.next
	        mid.next = None
	        
	        print(head1.val, head2.val)
	        
	        head1 = self.sortList(head1)
	        head2 = self.sortList(head2)
	        
	        return self.merge(head1, head2)
            
要注意的有以下几个地方

1. 由于链表不能随机访问，因此切中点的时候需要使用快慢指针来找到中间点切分。
2. 中间点有一个很难的地方，就是在什么时候停止，其实我们应该找到的是中间点前一个的node，因此停止条件应该是fast.next.next为空，slow后面那个就是mid。
3. 注意，slow后面赋值给head2后，就要把slow后面清掉，否则会无限递归。
4. merge过程用链表反而好写了很多，没有什么大坑。
         
补充法二：链表版快速排序 

这个方法过不了所有样例，只是作为补充

	# Definition for singly-linked list.
	# class ListNode(object):
	#     def __init__(self, x):
	#         self.val = x
	#         self.next = None
	
	class Solution(object):
	    def sortList(self, head):
	        """
	        :type head: ListNode
	        :rtype: ListNode
	        """
	        
	        def parition(head, end):
	            if head == None or head == end:
	                return 
	            p = head.next
	            small = head
	            
	            while p != end:
	                if p.val < head.val:
	                    small = small.next  # 先移动small，再交换，和数组里版本一致
	                    t = small.val
	                    small.val = p.val
	                    p.val = t
	                p = p.next
	                
	            t = head.val  # 这里不需要再移动small了，因为我们用的第一个作为base
	            head.val = small.val
	            small.val = t
	            
	            return small
	        
	        def quickSort(head, end): 
	            if head == end or head.next == end: # 确保有两个节点
	                return
	            splitNode = parition(head, end)
	            quickSort(head, splitNode)
	            quickSort(splitNode.next, end)
	        
	        if head == None or head.next == None:
	            return head
	        quickSort(head, None)  # end就是none
	        return head            
        